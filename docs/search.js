window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "antspyt1w", "modulename": "antspyt1w", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "antspyt1w.get_data", "modulename": "antspyt1w.get_data", "kind": "module", "doc": "<p>Get local ANTsPyT1w data</p>\n"}, {"fullname": "antspyt1w.get_data.get_data", "modulename": "antspyt1w.get_data", "qualname": "get_data", "kind": "function", "doc": "<p>Get ANTsPyT1w data filename</p>\n\n<p>The first time this is called, it will download data to ~/.antspyt1w.\nAfter, it will just read data from disk.  The ~/.antspyt1w may need to\nbe periodically deleted in order to ensure data is current.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>name : string\n    name of data tag to retrieve\n    Options:\n        - 'all'\n        - 'dkt'\n        - 'hemisphere'\n        - 'lobes'\n        - 'tissues'\n        - 'T_template0'\n        - 'T_template0_LR'\n        - 'T_template0_LobesBstem'\n        - 'T_template0_WMP'\n        - 'T_template0_Symmetric'\n        - 'T_template0_SymmetricLR'\n        - 'PPMI-3803-20120814-MRI_T1-I340756'\n        - 'simwmseg'\n        - 'simwmdisc'\n        - 'wmh_evidence'\n        - 'wm_major_tracts'</p>\n\n<p>force_download: boolean</p>\n\n<p>version: version of data to download (integer)</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>string\n    filepath of selected data</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">ants</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ppmi</span> <span class=\"o\">=</span> <span class=\"n\">ants</span><span class=\"o\">.</span><span class=\"n\">get_ants_data</span><span class=\"p\">(</span><span class=\"s1\">&#39;ppmi&#39;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">force_download</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">version</span><span class=\"o\">=</span><span class=\"mi\">46</span>, </span><span class=\"param\"><span class=\"n\">target_extension</span><span class=\"o\">=</span><span class=\"s1\">&#39;.csv&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspyt1w.get_data.map_segmentation_to_dataframe", "modulename": "antspyt1w.get_data", "qualname": "map_segmentation_to_dataframe", "kind": "function", "doc": "<p>Match the segmentation to its appropriate data frame.  We do not check\nif the segmentation_type and segmentation_image match; this may be indicated\nby the number of missing values on output eg in column VolumeInMillimeters.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>segmentation_type : string\n    name of segmentation_type data frame to retrieve\n    Options:\n        - 'dkt'\n        - 'lobes'\n        - 'tissues'\n        - 'hemisphere'\n        - 'wm_major_tracts'</p>\n\n<p>segmentation_image : antsImage with same values (or mostly the same) as are\n    expected by segmentation_type</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dataframe</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">segmentation_type</span>, </span><span class=\"param\"><span class=\"n\">segmentation_image</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspyt1w.get_data.hierarchical", "modulename": "antspyt1w.get_data", "qualname": "hierarchical", "kind": "function", "doc": "<p>Default processing for a T1-weighted image.  See README.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>x : T1-weighted neuroimage antsImage</p>\n\n<p>output_prefix: string directory and prefix</p>\n\n<p>labels_to_register: list of integer segmentation labels (of 1 to 6 as defined\nby atropos: csf, gm, wm, dgm, brainstem, cerebellum) to define\nthe tissue types / regions of the brain to register.  set to None to\nskip registration which will be faster but omit some results.</p>\n\n<p>imgbxt : pre-existing brain extraction - a binary image - will disable some processing</p>\n\n<p>img6seg: pre-existing brain segmentation - a 6-class image ( ANTs standard )</p>\n\n<p>cit168 : boolean returns labels from CIT168 atlas with high-resolution registration\n    otherwise, low-resolution regitration is used.</p>\n\n<p>is_test: boolean ( parameters to run more quickly but with low quality )</p>\n\n<p>atropos_prior: prior weight for atropos post-processing; set to None if you\n    do not want to use this.  will modify the CSF, GM and WM segmentation to\n    better fit the image intensity at the resolution of the input image.</p>\n\n<p>sr_model: optional will trigger sr-based upsampling in some functions.</p>\n\n<p>verbose: boolean</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dataframes and associated derived data</p>\n\n<pre><code>- brain_n4_dnz : extracted brain denoised and bias corrected\n- brain_extraction : brain mask\n- rbp:  random basis projection results\n- left_right : left righ hemisphere segmentation\n- dkt_parc : dictionary object containing segmentation labels\n- registration : dictionary object containing registration results\n- hippLR : dictionary object containing hippocampus results\n- medial_temporal_lobe : dictionary object containing deep_flash (medial temporal lobe parcellation) results\n- white_matter_hypointensity : dictionary object containing WMH results\n- wm_tractsL  : white matter tracts, left\n- wm_tractsR  : white matter tracts, right\n- dataframes : summary data frames\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span>,</span><span class=\"param\">\t<span class=\"n\">output_prefix</span>,</span><span class=\"param\">\t<span class=\"n\">labels_to_register</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">imgbxt</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">img6seg</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cit168</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">is_test</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">atropos_prior</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">sr_model</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspyt1w.get_data.random_basis_projection", "modulename": "antspyt1w.get_data", "qualname": "random_basis_projection", "kind": "function", "doc": "<p>Produce unbiased data descriptors for a given image which can be used\nto assist data inspection and ranking.  can be used with any image\nbrain extracted or not, any modality etc.   but we assume we can\nmeaningfully map to a template, at least with a low-dimensional\ntransformation, e.g. Translation, Rigid, Similarity.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>x : antsImage</p>\n\n<p>template : antsImage reference template</p>\n\n<p>type_of_transform: one of Translation, Rigid, Similarity, Affine</p>\n\n<p>refbases : reference bases for outlierness calculations</p>\n\n<p>nBasis : number of variables to derive</p>\n\n<p>random_state : seed</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dataframe with projections and an outlierness estimate.</p>\n\n<p>the outlierness estimate is based on a small reference dataset of young controls.\nthe user/researcher may want to use a different reference set.  see the\nfunction loop_outlierness for one way to do that.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span>,</span><span class=\"param\">\t<span class=\"n\">template</span>,</span><span class=\"param\">\t<span class=\"n\">type_of_transform</span><span class=\"o\">=</span><span class=\"s1\">&#39;Similarity&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">refbases</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nBasis</span><span class=\"o\">=</span><span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">random_state</span><span class=\"o\">=</span><span class=\"mi\">99</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspyt1w.get_data.deep_dkt", "modulename": "antspyt1w.get_data", "qualname": "deep_dkt", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "antspyt1w.get_data.deep_hippo", "modulename": "antspyt1w.get_data", "qualname": "deep_hippo", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">img</span>,</span><span class=\"param\">\t<span class=\"n\">template</span>,</span><span class=\"param\">\t<span class=\"n\">number_of_tries</span><span class=\"o\">=</span><span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">tx_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;antsRegistrationSyNQuickRepro[a]&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">sr_model</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspyt1w.get_data.deep_tissue_segmentation", "modulename": "antspyt1w.get_data", "qualname": "deep_tissue_segmentation", "kind": "function", "doc": "<p>modified slightly more efficient deep atropos that also handles the\nextra CSF issue.  returns segmentation and probability images. see\nthe tissues csv available from get_data.</p>\n\n<p>x: input image, raw</p>\n\n<p>template: MNI space template, should be \"croppedMni152\" or \"biobank\"</p>\n\n<p>registration_map: pre-existing output from ants.registration</p>\n\n<p>atropos_prior: prior weight for atropos post-processing; set to None if you\n    do not want to use this.  will modify the CSF, GM and WM segmentation to\n    better fit the image intensity at the resolution of the input image.</p>\n\n<p>sr_model: optional (FIXME)</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span>,</span><span class=\"param\">\t<span class=\"n\">template</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">registration_map</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">atropos_prior</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">sr_model</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspyt1w.get_data.deep_brain_parcellation", "modulename": "antspyt1w.get_data", "qualname": "deep_brain_parcellation", "kind": "function", "doc": "<p>modified slightly more efficient deep dkt that also returns atropos output\nthus providing a complete hierarchical parcellation of t1w.  we run atropos\nhere so we dont need to redo registration separately. see\nthe lobes and dkt csv available from get_data.</p>\n\n<p>target_image: input image</p>\n\n<p>template: MNI space template, should be \"croppedMni152\" or \"biobank\"</p>\n\n<p>img6seg: optional pre-existing brain segmentation - a 6-class image ( ANTs standard )</p>\n\n<p>do_cortical_propagation: boolean, adds a bit extra time to propagate cortical\n    labels explicitly into cortical segmentation</p>\n\n<p>atropos_prior: prior weight for atropos post-processing; set to None if you\n    do not want to use this.  will modify the CSF, GM and WM segmentation to\n    better fit the image intensity at the resolution of the input image.</p>\n\n<p>verbose: boolean</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>a dictionary containing:</p>\n\n<ul>\n<li>tissue_segmentation : 6 tissue segmentation</li>\n<li>tissue_probabilities : probability images associated with above</li>\n<li>dkt_parcellation : tissue agnostic DKT parcellation</li>\n<li>dkt_lobes : major lobes of the brain</li>\n<li>dkt_cortex: cortical tissue DKT parcellation (if requested)</li>\n<li>hemisphere_labels: free to get hemisphere labels</li>\n<li>wmSNR : white matter signal-to-noise ratio</li>\n<li>wmcsfSNR : white matter to csf signal-to-noise ratio</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">target_image</span>,</span><span class=\"param\">\t<span class=\"n\">template</span>,</span><span class=\"param\">\t<span class=\"n\">img6seg</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">do_cortical_propagation</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">atropos_prior</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspyt1w.get_data.deep_mtl", "modulename": "antspyt1w.get_data", "qualname": "deep_mtl", "kind": "function", "doc": "<p>Hippocampal/Enthorhinal segmentation using \"Deep Flash\"</p>\n\n<p>Perform hippocampal/entorhinal segmentation in T1 images using\nlabels from Mike Yassa's lab</p>\n\n<p><a href=\"https://faculty.sites.uci.edu/myassa/\">https://faculty.sites.uci.edu/myassa/</a></p>\n\n<p>The labeling is as follows:\nLabel 0 :  background\nLabel 5 :  left aLEC\nLabel 6 :  right aLEC\nLabel 7 :  left pMEC\nLabel 8 :  right pMEC\nLabel 9 :  left perirhinal\nLabel 10:  right perirhinal\nLabel 11:  left parahippocampal\nLabel 12:  right parahippocampal\nLabel 13:  left DG/CA3\nLabel 14:  right DG/CA3\nLabel 15:  left CA1\nLabel 16:  right CA1\nLabel 17:  left subiculum\nLabel 18:  right subiculum</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t1</span>, </span><span class=\"param\"><span class=\"n\">sr_model</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspyt1w.get_data.label_hemispheres", "modulename": "antspyt1w.get_data", "qualname": "label_hemispheres", "kind": "function", "doc": "<p>quick somewhat noisy registration solution to hemisphere labeling. typically\nwe label left as 1 and right as 2.</p>\n\n<p>x: input image</p>\n\n<p>template: MNI space template, should be \"croppedMni152\" or \"biobank\"</p>\n\n<p>templateLR: a segmentation image of template hemispheres</p>\n\n<p>reg_iterations: reg_iterations for ants.registration</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">template</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">templateLR</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">reg_iterations</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">200</span><span class=\"p\">,</span> <span class=\"mi\">50</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspyt1w.get_data.brain_extraction", "modulename": "antspyt1w.get_data", "qualname": "brain_extraction", "kind": "function", "doc": "<p>quick brain extraction for individual images</p>\n\n<p>x: input image</p>\n\n<p>dilation: amount to dilate first brain extraction in millimeters</p>\n\n<p>method: version currently v0 or any other string gives two different results</p>\n\n<p>deform: map the image to the training hypersphere before running the extraction</p>\n\n<p>verbose: boolean</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">dilation</span><span class=\"o\">=</span><span class=\"mf\">8.0</span>, </span><span class=\"param\"><span class=\"n\">method</span><span class=\"o\">=</span><span class=\"s1\">&#39;v1&#39;</span>, </span><span class=\"param\"><span class=\"n\">deform</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspyt1w.get_data.hemi_reg", "modulename": "antspyt1w.get_data", "qualname": "hemi_reg", "kind": "function", "doc": "<p>hemisphere focused registration that will produce jacobians and figures to\nsupport data inspection</p>\n\n<p>input_image: input image</p>\n\n<p>input_image_tissue_segmentation: segmentation produced in ANTs style ie with\nlabels defined by atropos brain segmentation (1 to 6)</p>\n\n<p>input_image_hemisphere_segmentation: left (1) and right (2) hemisphere\nsegmentation</p>\n\n<p>input_template: template to which we register; prefer a population-specific\nrelatively high-resolution template instead of MNI or biobank.</p>\n\n<p>input_template_hemisphere_labels: a segmentation image of template hemispheres\nwith left labeled 1 and right labeled 2</p>\n\n<p>output_prefix: a path and prefix for registration related outputs</p>\n\n<p>padding: number of voxels to pad images, needed for diffzero</p>\n\n<p>labels_to_register: list of integer segmentation labels to use to define\nthe tissue types / regions of the brain to register.</p>\n\n<p>total_sigma: scalar &gt;= 0.0 ; higher means more constrained registration.</p>\n\n<p>is_test: boolean. this function can be long running by default. this would\nhelp testing more quickly by running fewer iterations.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">input_image</span>,</span><span class=\"param\">\t<span class=\"n\">input_image_tissue_segmentation</span>,</span><span class=\"param\">\t<span class=\"n\">input_image_hemisphere_segmentation</span>,</span><span class=\"param\">\t<span class=\"n\">input_template</span>,</span><span class=\"param\">\t<span class=\"n\">input_template_hemisphere_labels</span>,</span><span class=\"param\">\t<span class=\"n\">output_prefix</span>,</span><span class=\"param\">\t<span class=\"n\">padding</span><span class=\"o\">=</span><span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">labels_to_register</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">total_sigma</span><span class=\"o\">=</span><span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">is_test</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspyt1w.get_data.region_reg", "modulename": "antspyt1w.get_data", "qualname": "region_reg", "kind": "function", "doc": "<p>region focused registration that will produce jacobians and figures to\nsupport data inspection.  region-defining images should be binary.</p>\n\n<p>input_image: input image</p>\n\n<p>input_image_tissue_segmentation: segmentation produced in ANTs style ie with\nlabels defined by atropos brain segmentation (1 to 6)</p>\n\n<p>input_image_region_segmentation: a local region to register - binary.</p>\n\n<p>input_template: template to which we register; prefer a population-specific\nrelatively high-resolution template instead of MNI or biobank. brain extracted.</p>\n\n<p>input_template_region_segmentation: a segmentation image of template regions - binary.</p>\n\n<p>output_prefix: a path and prefix for registration related outputs</p>\n\n<p>padding: number of voxels to pad images, needed for diffzero</p>\n\n<p>total_sigma: scalar &gt;= 0.0 ; higher means more constrained registration.</p>\n\n<p>is_test: boolean. this function can be long running by default. this would\nhelp testing more quickly by running fewer iterations.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">input_image</span>,</span><span class=\"param\">\t<span class=\"n\">input_image_tissue_segmentation</span>,</span><span class=\"param\">\t<span class=\"n\">input_image_region_segmentation</span>,</span><span class=\"param\">\t<span class=\"n\">input_template</span>,</span><span class=\"param\">\t<span class=\"n\">input_template_region_segmentation</span>,</span><span class=\"param\">\t<span class=\"n\">output_prefix</span>,</span><span class=\"param\">\t<span class=\"n\">padding</span><span class=\"o\">=</span><span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">total_sigma</span><span class=\"o\">=</span><span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">is_test</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspyt1w.get_data.t1_hypointensity", "modulename": "antspyt1w.get_data", "qualname": "t1_hypointensity", "kind": "function", "doc": "<p>provide measurements that may help decide if a given t1 image is likely\nto have hypointensity.</p>\n\n<p>x: input image; bias-corrected, brain-extracted and denoised</p>\n\n<p>xsegmentation: input image hard-segmentation results</p>\n\n<p>xWMProbability: input image WM probability</p>\n\n<p>template: template image</p>\n\n<p>templateWMPrior: template tissue prior</p>\n\n<p>wmh_thresh: float used to threshold WMH probability and produce summary data</p>\n\n<p>returns:</p>\n\n<pre><code>- wmh_summary: summary data frame based on thresholding WMH probability at wmh_thresh\n- wmh_probability_image: probability image denoting WMH probability; higher values indicate\n  that WMH is more likely\n- wmh_evidence_of_existence: an integral evidence that indicates the likelihood that the input\n    image content supports the presence of white matter hypointensity.\n    greater than zero is supportive of WMH.  the higher, the more so.\n    less than zero is evidence against.\n- wmh_max_prob: max probability of wmh\n- features: the features driving WMH predictons\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span>,</span><span class=\"param\">\t<span class=\"n\">xsegmentation</span>,</span><span class=\"param\">\t<span class=\"n\">xWMProbability</span>,</span><span class=\"param\">\t<span class=\"n\">template</span>,</span><span class=\"param\">\t<span class=\"n\">templateWMPrior</span>,</span><span class=\"param\">\t<span class=\"n\">wmh_thresh</span><span class=\"o\">=</span><span class=\"mf\">0.1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspyt1w.get_data.zoom_syn", "modulename": "antspyt1w.get_data", "qualname": "zoom_syn", "kind": "function", "doc": "<p>zoomed in syn - a hierarchical registration applied to a hierarchical segmentation</p>\n\n<p>Initial registration is followed up by a refined and focused high-resolution registration.\nThis is performed on the cropped image where the cropping region is determined\nby the first segmentation in the template_segmentations list.  Segmentations\nafter the first one are assumed to exist as sub-regions of the first.  All\nsegmentations are assumed to be binary.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>target_image : ants image at original resolution</p>\n\n<p>template : ants image template to be mapped to the target image</p>\n\n<p>template_segmentations : list of binary segmentation images</p>\n\n<p>dilation : morphological dilation amount applied to the first segmentation and used for cropping</p>\n\n<p>regIterations : parameter passed to ants.registration</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dictionary\n    containing segmentation and registration results in addition to cropping results</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">ants</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ireg</span> <span class=\"o\">=</span> <span class=\"n\">ants</span><span class=\"o\">.</span><span class=\"n\">registration</span><span class=\"p\">(</span> <span class=\"n\">target_image</span><span class=\"p\">,</span> <span class=\"n\">template</span><span class=\"p\">,</span> <span class=\"s2\">&quot;antsRegistrationSyNQuickRepro[s]&quot;</span> <span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">xxx</span> <span class=\"o\">=</span> <span class=\"n\">antspyt1w</span><span class=\"o\">.</span><span class=\"n\">zoom_syn</span><span class=\"p\">(</span>  <span class=\"n\">orb</span><span class=\"p\">,</span>  <span class=\"n\">template</span><span class=\"p\">,</span> <span class=\"n\">level2segs</span><span class=\"p\">,</span> <span class=\"n\">ireg</span> <span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">target_image</span>,</span><span class=\"param\">\t<span class=\"n\">template</span>,</span><span class=\"param\">\t<span class=\"n\">template_segmentations</span>,</span><span class=\"param\">\t<span class=\"n\">initial_registration</span>,</span><span class=\"param\">\t<span class=\"n\">dilation</span><span class=\"o\">=</span><span class=\"mi\">4</span>,</span><span class=\"param\">\t<span class=\"n\">regIterations</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">25</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspyt1w.get_data.merge_hierarchical_csvs_to_wide_format", "modulename": "antspyt1w.get_data", "qualname": "merge_hierarchical_csvs_to_wide_format", "kind": "function", "doc": "<p>standardized merging of output for dataframes produced by hierarchical function.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>hierarchical_dataframes : output of antspyt1w.hierarchical</p>\n\n<p>identifier : unique subject identifier e.g. subject_001</p>\n\n<p>identifier_name : string name for the unique identifer column e.g. subject_id</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>data frame in wide format</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">hierarchical_dataframes</span>,</span><span class=\"param\">\t<span class=\"n\">col_names</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">identifier</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">identifier_name</span><span class=\"o\">=</span><span class=\"s1\">&#39;u_hier_id&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspyt1w.get_data.map_intensity_to_dataframe", "modulename": "antspyt1w.get_data", "qualname": "map_intensity_to_dataframe", "kind": "function", "doc": "<p>Match intensity values within segmentation labels to an appropriate data frame.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>segmentation_type : string or pandas.DataFrame\n    If string:\n        Name of the segmentation type data frame to retrieve using get_data.\n        Options include data available via get_data (e.g., \"lobes\").\n    If pandas.DataFrame:\n        A pre-existing DataFrame containing label information.</p>\n\n<p>intensity_image : ants.ANTsImage\n    ANTsImage with intensity values to summarize.</p>\n\n<p>segmentation_image : ants.ANTsImage\n    ANTsImage with labels (or mostly the same values) as expected by segmentation_type.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>pandas.DataFrame\n    A DataFrame summarizing the intensity values within segmentation labels.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">segmentation_type</span>, </span><span class=\"param\"><span class=\"n\">intensity_image</span>, </span><span class=\"param\"><span class=\"n\">segmentation_image</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspyt1w.get_data.deep_nbm", "modulename": "antspyt1w.get_data", "qualname": "deep_nbm", "kind": "function", "doc": "<p>CH13 and Nucleus basalis of Meynert segmentation and subdivision</p>\n\n<p>Perform CH13 and NBM segmentation in T1 images using Avants labels.</p>\n\n<p>t1 : T1-weighted neuroimage antsImage - already brain extracted</p>\n\n<p>nbm_weights : string weight file for parcellating unet</p>\n\n<p>binary_mask : will restrict output to this mask</p>\n\n<p>deform : boolean to correct for image deformation</p>\n\n<p>aged_template : boolean to control which template to use</p>\n\n<p>csfquantile: if not None, will try to remove CSF from the image.\n    0.25 may be a good value to try.</p>\n\n<p>verbose: boolean</p>\n\n<p>The labeling is as follows:</p>\n\n<p>Label,Description,Side\n1,CH13_left,left\n2,CH13_right,right\n3,NBM_left_ant,left\n4,NBM_left_mid,left\n5,NBM_left_pos,left\n6,NBM_right_ant,right\n7,NBM_right_mid,right\n8,NBM_right_pos,right</p>\n\n<p>Failure modes will include odd image orientation (in which case you might\nuse the registration option).  A more nefarious issue can be a poor extraction\nof the cerebrum in the inferior frontal lobe.  These can be unpredictable\nbut if one sees a bad extraction, please check the mask that is output by\nthis function to see if it excludes non-cerebral tissue.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">t1</span>,</span><span class=\"param\">\t<span class=\"n\">nbm_weights</span>,</span><span class=\"param\">\t<span class=\"n\">binary_mask</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">deform</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">aged_template</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">csfquantile</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">reflect</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspyt1w.get_data.map_cit168", "modulename": "antspyt1w.get_data", "qualname": "map_cit168", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "antspyt1w.get_data.deep_cit168", "modulename": "antspyt1w.get_data", "qualname": "deep_cit168", "kind": "function", "doc": "<p>CIT168 atlas segmentation with a parcellation unet.</p>\n\n<p>Perform CIT168 segmentation in T1 images using Pauli atlas (CIT168) labels.</p>\n\n<p>t1 : T1-weighted neuroimage antsImage - already brain extracted.  image should\nbe normalized 0 to 1 and with a nicely uniform histogram (no major outliers).\nwe do a little work internally to help this but no guarantees it will handle\nall possible confounding issues.</p>\n\n<p>binary_mask : will restrict output to this mask</p>\n\n<p>syn_type : the type of registration used for generating priors; usually\n   either SyN or antsRegistrationSyNQuickRepro[s] for repeatable results</p>\n\n<p>priors : the user can provide their own priors through this argument; for\n   example, the user may run this function twice, with the output of the first\n   giving input to the second run.</p>\n\n<p>verbose: boolean</p>\n\n<p>Failure modes will primarily occur around red nucleus and caudate nucleus.\nFor the latter, one might consider masking by the ventricular CSF, in particular\nnear the anterior and inferior portion of the caudate in subjects with\nlarge ventricles.  Low quality images with high atropy are also likely outside\nof the current range of the trained models. Iterating the model may help.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">t1</span>,</span><span class=\"param\">\t<span class=\"n\">binary_mask</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">syn_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;antsRegistrationSyNQuickRepro[s]&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">priors</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspyt1w.get_data.minimal_sr_preprocessing", "modulename": "antspyt1w.get_data", "qualname": "minimal_sr_preprocessing", "kind": "function", "doc": "<p>x : input t1 image (raw)</p>\n\n<p>imgbxt : optional existing brain extraction</p>\n\n<p>outputs: preprocessedT1, hemisphereLabels</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">imgbxt</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();