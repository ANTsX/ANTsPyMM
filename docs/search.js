window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "antspymm", "modulename": "antspymm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "antspymm.mm", "modulename": "antspymm.mm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "antspymm.mm.version", "modulename": "antspymm.mm", "qualname": "version", "kind": "function", "doc": "<p>report versions of this package and primary dependencies</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>None</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>a dictionary with package name and versions</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">antspymm</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">antspymm</span><span class=\"o\">.</span><span class=\"n\">version</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.mm_read", "modulename": "antspymm.mm", "qualname": "mm_read", "kind": "function", "doc": "<p>read an image from a filename - same as ants.image_read (for now)</p>\n\n<p>standardize_intensity : boolean ; if True will set negative values to zero and normalize into the range of zero to one</p>\n\n<p>modality : not used</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">standardize_intensity</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">modality</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.mm_read_to_3d", "modulename": "antspymm.mm", "qualname": "mm_read_to_3d", "kind": "function", "doc": "<p>read an image from a filename - and return as 3d or None if that is not possible</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"nb\">slice</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">modality</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.image_write_with_thumbnail", "modulename": "antspymm.mm", "qualname": "image_write_with_thumbnail", "kind": "function", "doc": "<p>will write the image and (optionally) a png thumbnail with (optional) overlay/underlay</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">fn</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">thumb</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.nrg_format_path", "modulename": "antspymm.mm", "qualname": "nrg_format_path", "kind": "function", "doc": "<p>create the NRG path on disk given the project, subject id, date, modality and image id</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>projectID : string for the project e.g. PPMI</p>\n\n<p>subjectID : string uniquely identifying the subject e.g. 0001</p>\n\n<p>date : string for the date usually 20550228 ie YYYYMMDD format</p>\n\n<p>modality : string should be one of T1w, T2Flair, rsfMRI, NM2DMT and DTI ... rsfMRI and DTI may also be DTI_LR, DTI_RL, rsfMRI_LR and rsfMRI_RL where the RL / LR relates to phase encoding direction (even if it is AP/PA)</p>\n\n<p>imageID : string uniquely identifying the specific image</p>\n\n<p>separator : default to -</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>the path where one would write the image on disk</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">projectID</span>, </span><span class=\"param\"><span class=\"n\">subjectID</span>, </span><span class=\"param\"><span class=\"n\">date</span>, </span><span class=\"param\"><span class=\"n\">modality</span>, </span><span class=\"param\"><span class=\"n\">imageID</span>, </span><span class=\"param\"><span class=\"n\">separator</span><span class=\"o\">=</span><span class=\"s1\">&#39;-&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.highest_quality_repeat", "modulename": "antspymm.mm", "qualname": "highest_quality_repeat", "kind": "function", "doc": "<p>This function returns a subset of the input dataframe that retains only the rows\nthat correspond to the highest quality observation for each combination of ID and visit.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>mxdfin: pandas.DataFrame\n    The input dataframe.\nidvar: str\n    The name of the column that contains the ID variable.\nvisitvar: str\n    The name of the column that contains the visit variable.\nqualityvar: str\n    The name of the column that contains the quality variable.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>pandas.DataFrame\n    A subset of the input dataframe that retains only the rows that correspond\n    to the highest quality observation for each combination of ID and visit.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mxdfin</span>, </span><span class=\"param\"><span class=\"n\">idvar</span>, </span><span class=\"param\"><span class=\"n\">visitvar</span>, </span><span class=\"param\"><span class=\"n\">qualityvar</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.match_modalities", "modulename": "antspymm.mm", "qualname": "match_modalities", "kind": "function", "doc": "<p>Find the best multiple modality dataset at each time point</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>qc_dataframe</strong>:  quality control data frame with</li>\n<li><strong>unique_identifier</strong>:  the unique NRG filename for each image</li>\n<li><strong>outlier_column</strong>:  outlierness score used to identify the best image (pair) at a given date</li>\n<li><strong>mysep (str, optional)</strong>:  the separator used in the image file names. Defaults to '-'.</li>\n<li><strong>verbose</strong>:  boolean</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>filtered matched modality data frame</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">qc_dataframe</span>,</span><span class=\"param\">\t<span class=\"n\">unique_identifier</span><span class=\"o\">=</span><span class=\"s1\">&#39;filename&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">outlier_column</span><span class=\"o\">=</span><span class=\"s1\">&#39;ol_loop&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">mysep</span><span class=\"o\">=</span><span class=\"s1\">&#39;-&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.mc_resample_image_to_target", "modulename": "antspymm.mm", "qualname": "mc_resample_image_to_target", "kind": "function", "doc": "<p>multichannel version of resample_image_to_target</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">interp_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;linear&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.nrg_filelist_to_dataframe", "modulename": "antspymm.mm", "qualname": "nrg_filelist_to_dataframe", "kind": "function", "doc": "<p>convert a list of files in nrg format to a dataframe</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>filename_list : globbed list of files</p>\n\n<p>myseparator : string separator between nrg parts</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>df : pandas data frame</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename_list</span>, </span><span class=\"param\"><span class=\"n\">myseparator</span><span class=\"o\">=</span><span class=\"s1\">&#39;-&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.merge_timeseries_data", "modulename": "antspymm.mm", "qualname": "merge_timeseries_data", "kind": "function", "doc": "<p>merge time series data into space of reference_image</p>\n\n<p>img_LR : image</p>\n\n<p>img_RL : image</p>\n\n<p>allow_resample : boolean</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">img_LR</span>, </span><span class=\"param\"><span class=\"n\">img_RL</span>, </span><span class=\"param\"><span class=\"n\">allow_resample</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.timeseries_reg", "modulename": "antspymm.mm", "qualname": "timeseries_reg", "kind": "function", "doc": "<p>Correct time-series data for motion.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>image: antsImage, usually ND where D=4.</p>\n\n<p>avg_b0: Fixed image b0 image</p>\n\n<p>type_of_transform : string\n        A linear or non-linear registration type. Mutual information metric and rigid transformation by default.\n        See ants registration for details.</p>\n\n<p>fdOffset: offset value to use in framewise displacement calculation</p>\n\n<p>trim : integer - trim this many images off the front of the time series</p>\n\n<p>output_directory : string\n        output will be placed in this directory plus a numeric extension.</p>\n\n<p>return_numpy_motion_parameters : boolean</p>\n\n<p>verbose: boolean</p>\n\n<p>kwargs: keyword args\n        extra arguments - these extra arguments will control the details of registration that is performed. see ants registration for more.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict containing follow key/value pairs:\n    <code>motion_corrected</code>: Moving image warped to space of fixed image.\n    <code>motion_parameters</code>: transforms for each image in the time series.\n    <code>FD</code>: Framewise displacement generalized for arbitrary transformations.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Control extra arguments via kwargs. see ants.registration for details.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">ants</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">image</span>,</span><span class=\"param\">\t<span class=\"n\">avg_b0</span>,</span><span class=\"param\">\t<span class=\"n\">type_of_transform</span><span class=\"o\">=</span><span class=\"s1\">&#39;antsRegistrationSyNRepro[r]&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">total_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">fdOffset</span><span class=\"o\">=</span><span class=\"mf\">2.0</span>,</span><span class=\"param\">\t<span class=\"n\">trim</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">output_directory</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">return_numpy_motion_parameters</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.merge_dwi_data", "modulename": "antspymm.mm", "qualname": "merge_dwi_data", "kind": "function", "doc": "<p>merge motion and distortion corrected data if possible</p>\n\n<p>img_LRdwp : image</p>\n\n<p>bval_LR : array</p>\n\n<p>bvec_LR : array</p>\n\n<p>img_RLdwp : image</p>\n\n<p>bval_RL : array</p>\n\n<p>bvec_RL : array</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">img_LRdwp</span>, </span><span class=\"param\"><span class=\"n\">bval_LR</span>, </span><span class=\"param\"><span class=\"n\">bvec_LR</span>, </span><span class=\"param\"><span class=\"n\">img_RLdwp</span>, </span><span class=\"param\"><span class=\"n\">bval_RL</span>, </span><span class=\"param\"><span class=\"n\">bvec_RL</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.outlierness_by_modality", "modulename": "antspymm.mm", "qualname": "outlierness_by_modality", "kind": "function", "doc": "<p>Calculates outlierness scores for each modality in a dataframe based on given outlier columns using antspyt1w.loop_outlierness() and LOF.  LOF appears to be more conservative.  This function will impute missing columns with the mean.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>qcdf: (Pandas DataFrame) Dataframe containing columns with outlier information for each modality.</li>\n<li>uid: (str) Unique identifier for a subject. Default is 'filename'.</li>\n<li>outlier_columns: (list) List of columns containing outlier information. Default is ['noise', 'snr', 'cnr', 'psnr', 'ssim', 'mi', 'reflection_err', 'EVR', 'msk_vol'].</li>\n<li>verbose: (bool) If True, prints information for each modality. Default is False.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>qcdf: (Pandas DataFrame) Updated dataframe with outlierness scores for each modality in the 'ol_loop' and 'ol_lof' column.  Higher values near 1 are more outlying.</li>\n</ul>\n\n<p>Raises:</p>\n\n<ul>\n<li>ValueError: If uid is not present in the dataframe.</li>\n</ul>\n\n<p>Example:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">read_csv</span><span class=\"p\">(</span><span class=\"s1\">&#39;data.csv&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">outlierness_by_modality</span><span class=\"p\">(</span><span class=\"n\">df</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">qcdf</span>,</span><span class=\"param\">\t<span class=\"n\">uid</span><span class=\"o\">=</span><span class=\"s1\">&#39;filename&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">outlier_columns</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">&#39;noise&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;snr&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;cnr&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;psnr&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;ssim&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;mi&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;reflection_err&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;EVR&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;msk_vol&#39;</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.bvec_reorientation", "modulename": "antspymm.mm", "qualname": "bvec_reorientation", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">motion_parameters</span>, </span><span class=\"param\"><span class=\"n\">bvecs</span>, </span><span class=\"param\"><span class=\"n\">rebase</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.get_dti", "modulename": "antspymm.mm", "qualname": "get_dti", "kind": "function", "doc": "<p>extract DTI data from a dipy tensormodel</p>\n\n<p>reference_image : antsImage defining physical space (3D)</p>\n\n<p>tensormodel : from dipy e.g. the variable myoutx['dtrecon_LR_dewarp']['tensormodel'] if myoutx is produced my joint_dti_recon</p>\n\n<p>upper_triangular: boolean otherwise use lower triangular coding</p>\n\n<p>return_image : boolean return the ANTsImage form of DTI otherwise return an array</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>either an ANTsImage (dim=X.Y.Z with 6 component voxels, upper triangular form)\n    or a 5D NumPy array (dim=X.Y.Z.3.3)</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>DiPy returns lower triangular form but ANTs expects upper triangular.\n    Here, we default to the ANTs standard but could generalize in the future \n    because not much here depends on ANTs standards of tensor data.\n    ANTs xx,xy,xz,yy,yz,zz\n    DiPy Dxx, Dxy, Dyy, Dxz, Dyz, Dzz</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">reference_image</span>,</span><span class=\"param\">\t<span class=\"n\">tensormodel</span>,</span><span class=\"param\">\t<span class=\"n\">upper_triangular</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">return_image</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.dti_reg", "modulename": "antspymm.mm", "qualname": "dti_reg", "kind": "function", "doc": "<p>Correct time-series data for motion - with optional deformation.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<pre><code>image: antsImage, usually ND where D=4.\n\navg_b0: Fixed image b0 image\n\navg_dwi: Fixed dwi same space as b0 image\n\nbvals: bvalues (file or array)\n\nbvecs: bvecs (file or array)\n\nb0_idx: indices of b0\n\ntype_of_transform : string\n    A linear or non-linear registration type. Mutual information metric and rigid transformation by default.\n    See ants registration for details.\n\nfdOffset: offset value to use in framewise displacement calculation\n\nmask_csf: boolean\n\nbrain_mask_eroded: optional mask that will trigger mixed interpolation\n\noutput_directory : string\n    output will be placed in this directory plus a numeric extension.\n\nverbose: boolean\n\nkwargs: keyword args\n    extra arguments - these extra arguments will control the details of registration that is performed. see ants registration for more.\n</code></pre>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict containing follow key/value pairs:\n    <code>motion_corrected</code>: Moving image warped to space of fixed image.\n    <code>motion_parameters</code>: transforms for each image in the time series.\n    <code>FD</code>: Framewise displacement generalized for arbitrary transformations.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Control extra arguments via kwargs. see ants.registration for details.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">ants</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">image</span>,</span><span class=\"param\">\t<span class=\"n\">avg_b0</span>,</span><span class=\"param\">\t<span class=\"n\">avg_dwi</span>,</span><span class=\"param\">\t<span class=\"n\">bvals</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bvecs</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">b0_idx</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">type_of_transform</span><span class=\"o\">=</span><span class=\"s1\">&#39;antsRegistrationSyNRepro[r]&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">total_sigma</span><span class=\"o\">=</span><span class=\"mf\">3.0</span>,</span><span class=\"param\">\t<span class=\"n\">fdOffset</span><span class=\"o\">=</span><span class=\"mf\">2.0</span>,</span><span class=\"param\">\t<span class=\"n\">mask_csf</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">brain_mask_eroded</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">output_directory</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.mc_reg", "modulename": "antspymm.mm", "qualname": "mc_reg", "kind": "function", "doc": "<p>Correct time-series data for motion - with deformation.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<pre><code>image: antsImage, usually ND where D=4.\n\nfixed: Fixed image to register all timepoints to.  If not provided,\n    mean image is used.\n\ntype_of_transform : string\n    A linear or non-linear registration type. Mutual information metric and rigid transformation by default.\n    See ants registration for details.\n\nfdOffset: offset value to use in framewise displacement calculation\n\noutput_directory : string\n    output will be named with this prefix plus a numeric extension.\n\nverbose: boolean\n\nkwargs: keyword args\n    extra arguments - these extra arguments will control the details of registration that is performed. see ants registration for more.\n</code></pre>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict containing follow key/value pairs:\n    <code>motion_corrected</code>: Moving image warped to space of fixed image.\n    <code>motion_parameters</code>: transforms for each image in the time series.\n    <code>FD</code>: Framewise displacement generalized for arbitrary transformations.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Control extra arguments via kwargs. see ants.registration for details.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">ants</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">fi</span> <span class=\"o\">=</span> <span class=\"n\">ants</span><span class=\"o\">.</span><span class=\"n\">image_read</span><span class=\"p\">(</span><span class=\"n\">ants</span><span class=\"o\">.</span><span class=\"n\">get_ants_data</span><span class=\"p\">(</span><span class=\"s1\">&#39;ch2&#39;</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">mytx</span> <span class=\"o\">=</span> <span class=\"n\">ants</span><span class=\"o\">.</span><span class=\"n\">motion_correction</span><span class=\"p\">(</span> <span class=\"n\">fi</span> <span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">image</span>,</span><span class=\"param\">\t<span class=\"n\">fixed</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">type_of_transform</span><span class=\"o\">=</span><span class=\"s1\">&#39;antsRegistrationSyNRepro[r]&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">total_sigma</span><span class=\"o\">=</span><span class=\"mf\">3.0</span>,</span><span class=\"param\">\t<span class=\"n\">fdOffset</span><span class=\"o\">=</span><span class=\"mf\">2.0</span>,</span><span class=\"param\">\t<span class=\"n\">output_directory</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.get_data", "modulename": "antspymm.mm", "qualname": "get_data", "kind": "function", "doc": "<p>Get ANTsPyMM data filename</p>\n\n<p>The first time this is called, it will download data to ~/.antspymm.\nAfter, it will just read data from disk.  The ~/.antspymm may need to\nbe periodically deleted in order to ensure data is current.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>name : string\n    name of data tag to retrieve\n    Options:\n        - 'all'</p>\n\n<p>force_download: boolean</p>\n\n<p>version: version of data to download (integer)</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>string\n    filepath of selected data</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">antspymm</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">antspymm</span><span class=\"o\">.</span><span class=\"n\">get_data</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">force_download</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">version</span><span class=\"o\">=</span><span class=\"mi\">26</span>, </span><span class=\"param\"><span class=\"n\">target_extension</span><span class=\"o\">=</span><span class=\"s1\">&#39;.csv&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.get_models", "modulename": "antspymm.mm", "qualname": "get_models", "kind": "function", "doc": "<p>Get ANTsPyMM data models</p>\n\n<p>force_download: boolean</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">version</span><span class=\"o\">=</span><span class=\"mi\">3</span>, </span><span class=\"param\"><span class=\"n\">force_download</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.get_valid_modalities", "modulename": "antspymm.mm", "qualname": "get_valid_modalities", "kind": "function", "doc": "<p>return a list of valid modality identifiers used in NRG modality designation\nand that can be processed by this package.</p>\n\n<p>long - return the long version</p>\n\n<p>asString - concat list to string</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">long</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">asString</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">qc</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.dewarp_imageset", "modulename": "antspymm.mm", "qualname": "dewarp_imageset", "kind": "function", "doc": "<p>Dewarp a set of images</p>\n\n<p>Makes simplifying heuristic decisions about how to transform an image set\ninto an unbiased reference space.  Will handle plenty of decisions\nautomatically so beware.  Computes an average shape space for the images\nand transforms them to that space.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>image_list : list containing antsImages 2D, 3D or 4D</p>\n\n<p>initial_template : optional</p>\n\n<p>iterations : number of template building iterations</p>\n\n<p>padding:  will pad the images by an integer amount to limit edge effects</p>\n\n<p>target_idx : the target indices for the time series over which we should average;\n    a list of integer indices into the last axis of the input images.</p>\n\n<p>kwargs : keyword args\n    arguments passed to ants registration - these must be set explicitly</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>a dictionary with the mean image and the list of the transformed images as\nwell as motion correction parameters for each image in the input list</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">antspymm</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">image_list</span>,</span><span class=\"param\">\t<span class=\"n\">initial_template</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">iterations</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">padding</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">target_idx</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.super_res_mcimage", "modulename": "antspymm.mm", "qualname": "super_res_mcimage", "kind": "function", "doc": "<p>Super resolution on a timeseries or multi-channel image</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>image : an antsImage</p>\n\n<p>srmodel : a tensorflow fully convolutional model</p>\n\n<p>truncation :  quantiles at which we truncate intensities to limit impact of outliers e.g. [0.005,0.995]</p>\n\n<p>poly_order : if not None, will fit a global regression model to map\n    intensity back to original histogram space; if 'hist' will match\n    by histogram matching - ants.histogram_match_image</p>\n\n<p>target_range : 2-element tuple\n    a tuple or array defining the (min, max) of the input image\n    (e.g., [-127.5, 127.5] or [0,1]).  Output images will be scaled back to original\n    intensity. This range should match the mapping used in the training\n    of the network.</p>\n\n<p>isotropic : boolean</p>\n\n<p>verbose : boolean</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>super resolution version of the image</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">antspymm</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">image</span>,</span><span class=\"param\">\t<span class=\"n\">srmodel</span>,</span><span class=\"param\">\t<span class=\"n\">truncation</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mf\">0.0001</span><span class=\"p\">,</span> <span class=\"mf\">0.995</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">poly_order</span><span class=\"o\">=</span><span class=\"s1\">&#39;hist&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">target_range</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">isotropic</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.segment_timeseries_by_meanvalue", "modulename": "antspymm.mm", "qualname": "segment_timeseries_by_meanvalue", "kind": "function", "doc": "<p>Identify indices of a time series where we assume there is a different mean\nintensity over the volumes.  The indices of volumes with higher and lower\nintensities is returned.  Can be used to automatically identify B0 volumes\nin DWI timeseries.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>image : an antsImage holding B0 and DWI</p>\n\n<p>quantile : a quantile for splitting the indices of the volume - should be greater than 0.5</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dictionary holding the two sets of indices</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">antspymm</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">image</span>, </span><span class=\"param\"><span class=\"n\">quantile</span><span class=\"o\">=</span><span class=\"mf\">0.995</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.get_average_rsf", "modulename": "antspymm.mm", "qualname": "get_average_rsf", "kind": "function", "doc": "<p>automatically generates the average bold image with quick registration</p>\n\n<p>returns:\n    avg_bold</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">min_t</span><span class=\"o\">=</span><span class=\"mi\">10</span>, </span><span class=\"param\"><span class=\"n\">max_t</span><span class=\"o\">=</span><span class=\"mi\">35</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.get_average_dwi_b0", "modulename": "antspymm.mm", "qualname": "get_average_dwi_b0", "kind": "function", "doc": "<p>automatically generates the average b0 and dwi and outputs both;\nmaps dwi to b0 space at end.</p>\n\n<p>x : input image</p>\n\n<p>fixed_b0 : alernative reference space</p>\n\n<p>fixed_dwi : alernative reference space</p>\n\n<p>fast : boolean</p>\n\n<p>returns:\n    avg_b0, avg_dwi</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">fixed_b0</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">fixed_dwi</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">fast</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.dti_template", "modulename": "antspymm.mm", "qualname": "dti_template", "kind": "function", "doc": "<p>two channel version of build_template</p>\n\n<p>returns:\n    avg_b0, avg_dwi</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">b_image_list</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">w_image_list</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">iterations</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">gradient_step</span><span class=\"o\">=</span><span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">mask_csf</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">average_both</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.t1_based_dwi_brain_extraction", "modulename": "antspymm.mm", "qualname": "t1_based_dwi_brain_extraction", "kind": "function", "doc": "<p>Map a t1-based brain extraction to b0 and return a mask and average b0</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>t1w_head : an antsImage of the hole head</p>\n\n<p>t1w : an antsImage probably but not necessarily T1-weighted</p>\n\n<p>dwi : an antsImage holding B0 and DWI</p>\n\n<p>b0_idx : the indices of the B0; if None, use segment_timeseries_by_meanvalue to guess</p>\n\n<p>transform : string Rigid or other ants.registration tx type</p>\n\n<p>deform : follow up transform with deformation</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dictionary holding the avg_b0 and its mask</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">antspymm</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">t1w_head</span>,</span><span class=\"param\">\t<span class=\"n\">t1w</span>,</span><span class=\"param\">\t<span class=\"n\">dwi</span>,</span><span class=\"param\">\t<span class=\"n\">b0_idx</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">transform</span><span class=\"o\">=</span><span class=\"s1\">&#39;antsRegistrationSyNRepro[r]&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">deform</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.mc_denoise", "modulename": "antspymm.mm", "qualname": "mc_denoise", "kind": "function", "doc": "<p>ants denoising for timeseries (4D)</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>x : an antsImage 4D</p>\n\n<p>ratio : weight between 1 and 0 - lower weights bring result closer to initial image</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>denoised time series</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">ratio</span><span class=\"o\">=</span><span class=\"mf\">0.5</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.tsnr", "modulename": "antspymm.mm", "qualname": "tsnr", "kind": "function", "doc": "<p>3D temporal snr image from a 4D time series image ... the matrix is normalized to range of 0,1</p>\n\n<p>x: image</p>\n\n<p>mask : mask</p>\n\n<p>indices: indices to use</p>\n\n<p>returns a 3D image</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">mask</span>, </span><span class=\"param\"><span class=\"n\">indices</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.dvars", "modulename": "antspymm.mm", "qualname": "dvars", "kind": "function", "doc": "<p>dvars on a time series image ... the matrix is normalized to range of 0,1</p>\n\n<p>x: image</p>\n\n<p>mask : mask</p>\n\n<p>indices: indices to use</p>\n\n<p>returns an array</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">mask</span>, </span><span class=\"param\"><span class=\"n\">indices</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.slice_snr", "modulename": "antspymm.mm", "qualname": "slice_snr", "kind": "function", "doc": "<p>slice-wise SNR on a time series image</p>\n\n<p>x: image</p>\n\n<p>background_mask : mask - maybe CSF or background or dilated brain mask minus original brain mask</p>\n\n<p>foreground_mask : mask - maybe cortex or WM or brain mask</p>\n\n<p>indices: indices to use</p>\n\n<p>returns an array</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">background_mask</span>, </span><span class=\"param\"><span class=\"n\">foreground_mask</span>, </span><span class=\"param\"><span class=\"n\">indices</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.impute_fa", "modulename": "antspymm.mm", "qualname": "impute_fa", "kind": "function", "doc": "<p>impute bad values in dti, fa, md</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fa</span>, </span><span class=\"param\"><span class=\"n\">md</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.trim_dti_mask", "modulename": "antspymm.mm", "qualname": "trim_dti_mask", "kind": "function", "doc": "<p>trim the dti mask to get rid of bright fa rim</p>\n\n<p>this function erodes the famask by param amount then segments the rim into\nbright and less bright parts.  the bright parts are trimmed from the mask\nand the remaining edges are cleaned up a bit with closing.</p>\n\n<p>param: closing radius unit is in physical space</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fa</span>, </span><span class=\"param\"><span class=\"n\">mask</span>, </span><span class=\"param\"><span class=\"n\">param</span><span class=\"o\">=</span><span class=\"mf\">4.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.dipy_dti_recon", "modulename": "antspymm.mm", "qualname": "dipy_dti_recon", "kind": "function", "doc": "<p>DiPy DTI reconstruction - building on the DiPy basic DTI example</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>image : an antsImage holding B0 and DWI</p>\n\n<p>bvalsfn : bvalues  obtained by dipy read_bvals_bvecs or the values themselves</p>\n\n<p>bvecsfn : bvectors obtained by dipy read_bvals_bvecs or the values themselves</p>\n\n<p>mask : brain mask for the DWI/DTI reconstruction; if it is not in the same\n    space as the image, we will resample directly to the image space.  This\n    could lead to problems if the inputs are really incorrect.</p>\n\n<p>b0_idx : the indices of the B0; if None, use segment_timeseries_by_bvalue</p>\n\n<p>mask_dilation : integer zero or more dilates the brain mask</p>\n\n<p>mask_closing : integer zero or more closes the brain mask</p>\n\n<p>fit_method : string one of WLS LS NLLS or restore - see import dipy.reconst.dti as dti and help(dti.TensorModel) ... if None, will not reconstruct DTI.</p>\n\n<p>trim_the_mask : float &gt;=0 post-hoc method for trimming the mask</p>\n\n<p>diffusion_model : string\n    DTI, FreeWater, DKI</p>\n\n<p>verbose : boolean</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dictionary holding the tensorfit, MD, FA and RGB images and motion parameters (optional)</p>\n\n<p>NOTE -- see dipy reorient_bvecs(gtab, affines, atol=1e-2)</p>\n\n<p>NOTE -- if the bvec.shape[0] is smaller than the image.shape[3], we neglect\n    the tailing image volumes.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">antspymm</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">image</span>,</span><span class=\"param\">\t<span class=\"n\">bvalsfn</span>,</span><span class=\"param\">\t<span class=\"n\">bvecsfn</span>,</span><span class=\"param\">\t<span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">b0_idx</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">mask_dilation</span><span class=\"o\">=</span><span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">mask_closing</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">fit_method</span><span class=\"o\">=</span><span class=\"s1\">&#39;WLS&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">trim_the_mask</span><span class=\"o\">=</span><span class=\"mf\">2.0</span>,</span><span class=\"param\">\t<span class=\"n\">diffusion_model</span><span class=\"o\">=</span><span class=\"s1\">&#39;DTI&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.concat_dewarp", "modulename": "antspymm.mm", "qualname": "concat_dewarp", "kind": "function", "doc": "<p>Apply concatentated motion correction and dewarping transforms to timeseries image.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>refimg : an antsImage defining the reference domain (3D)</p>\n\n<p>originalDWI : the antsImage in original (not interpolated space) (4D)</p>\n\n<p>physSpaceDWI : ants antsImage defining the physical space of the mapping (4D)</p>\n\n<p>dwpTx : dewarping transform</p>\n\n<p>motion_parameters : previously computed list of motion parameters</p>\n\n<p>motion_correct : boolean</p>\n\n<p>verbose : boolean</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">refimg</span>,</span><span class=\"param\">\t<span class=\"n\">originalDWI</span>,</span><span class=\"param\">\t<span class=\"n\">physSpaceDWI</span>,</span><span class=\"param\">\t<span class=\"n\">dwpTx</span>,</span><span class=\"param\">\t<span class=\"n\">motion_parameters</span>,</span><span class=\"param\">\t<span class=\"n\">motion_correct</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.joint_dti_recon", "modulename": "antspymm.mm", "qualname": "joint_dti_recon", "kind": "function", "doc": "<ol>\n<li>pass in subject data and 1mm JHU atlas/labels</li>\n<li>perform initial LR, RL reconstruction (2nd is optional) and motion correction (optional)</li>\n<li>dewarp the images using dewarp_modality or T1w</li>\n<li>apply dewarping to the original data\n===&gt; may want to apply SR at this step</li>\n<li>reconstruct DTI again</li>\n<li>label images and do registration</li>\n<li>return relevant outputs</li>\n</ol>\n\n<p>NOTE: RL images are optional; should pass t1w in this case.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>img_LR : an antsImage holding B0 and DWI LR acquisition</p>\n\n<p>bval_LR : bvalue filename LR</p>\n\n<p>bvec_LR : bvector filename LR</p>\n\n<p>jhu_atlas : atlas FA image</p>\n\n<p>jhu_labels : atlas labels</p>\n\n<p>reference_B0 : the \"target\" B0 image space</p>\n\n<p>reference_DWI : the \"target\" DW image space</p>\n\n<p>srmodel : optional h5 (tensorflow) model</p>\n\n<p>img_RL : an antsImage holding B0 and DWI RL acquisition</p>\n\n<p>bval_RL : bvalue filename RL</p>\n\n<p>bvec_RL : bvector filename RL</p>\n\n<p>t1w : antsimage t1w neuroimage (brain-extracted)</p>\n\n<p>brain_mask : mask for the DWI - just 3D - provided brain mask should be in reference_B0 space</p>\n\n<p>motion_correct : None Rigid or SyN</p>\n\n<p>dewarp_modality : string average_dwi, average_b0, MD or FA</p>\n\n<p>denoise: boolean</p>\n\n<p>fit_method : string one of WLS LS NLLS or restore - see import dipy.reconst.dti as dti and help(dti.TensorModel)</p>\n\n<p>impute : boolean</p>\n\n<p>censor : boolean</p>\n\n<p>diffusion_model : string\n    DTI, FreeWater, DKI</p>\n\n<p>verbose : boolean</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dictionary holding the mean_fa, its summary statistics via JHU labels,\n    the JHU registration, the JHU labels, the dewarping dictionary and the\n    dti reconstruction dictionaries.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">antspymm</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">img_LR</span>,</span><span class=\"param\">\t<span class=\"n\">bval_LR</span>,</span><span class=\"param\">\t<span class=\"n\">bvec_LR</span>,</span><span class=\"param\">\t<span class=\"n\">jhu_atlas</span>,</span><span class=\"param\">\t<span class=\"n\">jhu_labels</span>,</span><span class=\"param\">\t<span class=\"n\">reference_B0</span>,</span><span class=\"param\">\t<span class=\"n\">reference_DWI</span>,</span><span class=\"param\">\t<span class=\"n\">srmodel</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">img_RL</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bval_RL</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bvec_RL</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">t1w</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">brain_mask</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">motion_correct</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dewarp_modality</span><span class=\"o\">=</span><span class=\"s1\">&#39;FA&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">denoise</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">fit_method</span><span class=\"o\">=</span><span class=\"s1\">&#39;WLS&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">impute</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">censor</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">diffusion_model</span><span class=\"o\">=</span><span class=\"s1\">&#39;DTI&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.middle_slice_snr", "modulename": "antspymm.mm", "qualname": "middle_slice_snr", "kind": "function", "doc": "<p>Estimate signal to noise ratio (SNR) in 2D mid image from a 3D image.\nEstimates noise from a background mask which is a\ndilation of the foreground mask minus the foreground mask.\nActually estimates the reciprocal of the coefficient of variation.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>x : an antsImage</p>\n\n<p>background_dilation : integer - amount to dilate foreground mask</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">background_dilation</span><span class=\"o\">=</span><span class=\"mi\">5</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.foreground_background_snr", "modulename": "antspymm.mm", "qualname": "foreground_background_snr", "kind": "function", "doc": "<p>Estimate signal to noise ratio (SNR) in an image.\nEstimates noise from a background mask which is a\ndilation of the foreground mask minus the foreground mask.\nActually estimates the reciprocal of the coefficient of variation.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>x : an antsImage</p>\n\n<p>background_dilation : integer - amount to dilate foreground mask</p>\n\n<p>erode_foreground : boolean - 2nd option which erodes the initial\nforegound mask  to create a new foreground mask.  the background\nmask is the initial mask minus the eroded mask.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">background_dilation</span><span class=\"o\">=</span><span class=\"mi\">10</span>, </span><span class=\"param\"><span class=\"n\">erode_foreground</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.quantile_snr", "modulename": "antspymm.mm", "qualname": "quantile_snr", "kind": "function", "doc": "<p>Estimate signal to noise ratio (SNR) in an image.\nEstimates noise from a background mask which is a\ndilation of the foreground mask minus the foreground mask.\nActually estimates the reciprocal of the coefficient of variation.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>x : an antsImage</p>\n\n<p>lowest_quantile : float value &lt; 1 and &gt; 0</p>\n\n<p>low_quantile : float value &lt; 1 and &gt; 0</p>\n\n<p>high_quantile : float value &lt; 1 and &gt; 0</p>\n\n<p>highest_quantile : float value &lt; 1 and &gt; 0</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span>,</span><span class=\"param\">\t<span class=\"n\">lowest_quantile</span><span class=\"o\">=</span><span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">low_quantile</span><span class=\"o\">=</span><span class=\"mf\">0.1</span>,</span><span class=\"param\">\t<span class=\"n\">high_quantile</span><span class=\"o\">=</span><span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">highest_quantile</span><span class=\"o\">=</span><span class=\"mf\">0.95</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.mask_snr", "modulename": "antspymm.mm", "qualname": "mask_snr", "kind": "function", "doc": "<p>Estimate signal to noise ratio (SNR) in an image using\na user-defined foreground and background mask.\nActually estimates the reciprocal of the coefficient of variation.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>x : an antsImage</p>\n\n<p>background_mask : binary antsImage</p>\n\n<p>foreground_mask : binary antsImage</p>\n\n<p>bias_correct : boolean</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">background_mask</span>, </span><span class=\"param\"><span class=\"n\">foreground_mask</span>, </span><span class=\"param\"><span class=\"n\">bias_correct</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.dwi_deterministic_tracking", "modulename": "antspymm.mm", "qualname": "dwi_deterministic_tracking", "kind": "function", "doc": "<p>Performs deterministic tractography from the DWI and returns a tractogram\nand path length data frame.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>dwi : an antsImage holding DWI acquisition</p>\n\n<p>fa : an antsImage holding FA values</p>\n\n<p>bvals : bvalues</p>\n\n<p>bvecs : bvectors</p>\n\n<p>num_processes : number of subprocesses</p>\n\n<p>mask : mask within which to do tracking - if None, we will make a mask using the fa_thresh\n    and the code ants.threshold_image( fa, fa_thresh, 2.0 ).iMath(\"GetLargestComponent\")</p>\n\n<p>label_image : atlas labels</p>\n\n<p>seed_labels : list of label numbers from the atlas labels</p>\n\n<p>fa_thresh : 0.25 defaults</p>\n\n<p>seed_density : 1 default number of seeds per voxel</p>\n\n<p>step_size : for tracking</p>\n\n<p>peak_indices : pass these in, if they are previously estimated.  otherwise, will\n    compute on the fly (slow)</p>\n\n<p>fit_method : string one of WLS LS NLLS or restore - see import dipy.reconst.dti as dti and help(dti.TensorModel)</p>\n\n<p>verbose : boolean</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dictionary holding tracts and stateful object.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">antspymm</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dwi</span>,</span><span class=\"param\">\t<span class=\"n\">fa</span>,</span><span class=\"param\">\t<span class=\"n\">bvals</span>,</span><span class=\"param\">\t<span class=\"n\">bvecs</span>,</span><span class=\"param\">\t<span class=\"n\">num_processes</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">label_image</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">seed_labels</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fa_thresh</span><span class=\"o\">=</span><span class=\"mf\">0.05</span>,</span><span class=\"param\">\t<span class=\"n\">seed_density</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">step_size</span><span class=\"o\">=</span><span class=\"mf\">0.15</span>,</span><span class=\"param\">\t<span class=\"n\">peak_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fit_method</span><span class=\"o\">=</span><span class=\"s1\">&#39;WLS&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.dwi_closest_peak_tracking", "modulename": "antspymm.mm", "qualname": "dwi_closest_peak_tracking", "kind": "function", "doc": "<p>Performs deterministic tractography from the DWI and returns a tractogram\nand path length data frame.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>dwi : an antsImage holding DWI acquisition</p>\n\n<p>fa : an antsImage holding FA values</p>\n\n<p>bvals : bvalues</p>\n\n<p>bvecs : bvectors</p>\n\n<p>num_processes : number of subprocesses</p>\n\n<p>mask : mask within which to do tracking - if None, we will make a mask using the fa_thresh\n    and the code ants.threshold_image( fa, fa_thresh, 2.0 ).iMath(\"GetLargestComponent\")</p>\n\n<p>label_image : atlas labels</p>\n\n<p>seed_labels : list of label numbers from the atlas labels</p>\n\n<p>fa_thresh : 0.25 defaults</p>\n\n<p>seed_density : 1 default number of seeds per voxel</p>\n\n<p>step_size : for tracking</p>\n\n<p>peak_indices : pass these in, if they are previously estimated.  otherwise, will\n    compute on the fly (slow)</p>\n\n<p>verbose : boolean</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dictionary holding tracts and stateful object.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">antspymm</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dwi</span>,</span><span class=\"param\">\t<span class=\"n\">fa</span>,</span><span class=\"param\">\t<span class=\"n\">bvals</span>,</span><span class=\"param\">\t<span class=\"n\">bvecs</span>,</span><span class=\"param\">\t<span class=\"n\">num_processes</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">label_image</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">seed_labels</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fa_thresh</span><span class=\"o\">=</span><span class=\"mf\">0.05</span>,</span><span class=\"param\">\t<span class=\"n\">seed_density</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">step_size</span><span class=\"o\">=</span><span class=\"mf\">0.15</span>,</span><span class=\"param\">\t<span class=\"n\">peak_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.dwi_streamline_pairwise_connectivity", "modulename": "antspymm.mm", "qualname": "dwi_streamline_pairwise_connectivity", "kind": "function", "doc": "<p>Return streamlines connecting all of the regions in the label set. Ideal\nfor just 2 regions.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>streamlines : streamline object from dipy</p>\n\n<p>label_image : atlas labels</p>\n\n<p>labels_to_connect : list of 2 labels or [label,None]</p>\n\n<p>verbose : boolean</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>the subset of streamlines and a streamline count</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">antspymm</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">streamlines</span>, </span><span class=\"param\"><span class=\"n\">label_image</span>, </span><span class=\"param\"><span class=\"n\">labels_to_connect</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.dwi_streamline_connectivity", "modulename": "antspymm.mm", "qualname": "dwi_streamline_connectivity", "kind": "function", "doc": "<p>Summarize network connetivity of the input streamlines between all of the\nregions in the label set.</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>streamlines : streamline object from dipy</p>\n\n<p>label_image : atlas labels</p>\n\n<p>label_dataframe : pandas dataframe containing descriptions for the labels in antspy style (Label,Description columns)</p>\n\n<p>verbose : boolean</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dictionary holding summary connection statistics in wide format and matrix format.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">antspymm</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">streamlines</span>, </span><span class=\"param\"><span class=\"n\">label_image</span>, </span><span class=\"param\"><span class=\"n\">label_dataframe</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.hierarchical_modality_summary", "modulename": "antspymm.mm", "qualname": "hierarchical_modality_summary", "kind": "function", "doc": "<p>Use output of antspyt1w.hierarchical to summarize a modality</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>target_image : the image to summarize - should be brain extracted</p>\n\n<p>hier : dictionary holding antspyt1w.hierarchical output</p>\n\n<p>transformlist : spatial transformations mapping from T1 to this modality (e.g. from ants.registration)</p>\n\n<p>modality_name : adds the modality name to the data frame columns</p>\n\n<p>return_keys = [\"Mean\",\"Volume\"] keys to return</p>\n\n<p>verbose : boolean</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>data frame holding summary statistics in wide format</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">antspymm</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">target_image</span>,</span><span class=\"param\">\t<span class=\"n\">hier</span>,</span><span class=\"param\">\t<span class=\"n\">transformlist</span>,</span><span class=\"param\">\t<span class=\"n\">modality_name</span>,</span><span class=\"param\">\t<span class=\"n\">return_keys</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">&#39;Mean&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Volume&#39;</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.tra_initializer", "modulename": "antspymm.mm", "qualname": "tra_initializer", "kind": "function", "doc": "<p>multi-start multi-transform registration solution - based on ants.registration</p>\n\n<p>fixed: fixed image</p>\n\n<p>moving: moving image</p>\n\n<p>n_simulations : number of simulations</p>\n\n<p>max_rotation : maximum rotation angle</p>\n\n<p>transform : list of transforms to loop through</p>\n\n<p>compreg : registration results against which to compare</p>\n\n<p>random_seed : random seed for reproducibility</p>\n\n<p>verbose : boolean</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">fixed</span>,</span><span class=\"param\">\t<span class=\"n\">moving</span>,</span><span class=\"param\">\t<span class=\"n\">n_simulations</span><span class=\"o\">=</span><span class=\"mi\">32</span>,</span><span class=\"param\">\t<span class=\"n\">max_rotation</span><span class=\"o\">=</span><span class=\"mi\">30</span>,</span><span class=\"param\">\t<span class=\"n\">transform</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">&#39;rigid&#39;</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">compreg</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">random_seed</span><span class=\"o\">=</span><span class=\"mi\">42</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.neuromelanin", "modulename": "antspymm.mm", "qualname": "neuromelanin", "kind": "function", "doc": "<p>Outputs the averaged and registered neuromelanin image, and neuromelanin labels</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>list_nm_image : list of ANTsImages\n  list of neuromenlanin repeat images</p>\n\n<p>t1 : ANTsImage\n  input 3-D T1 brain image</p>\n\n<p>t1_head : ANTsImage\n  input 3-D T1 head image</p>\n\n<p>t1lab : ANTsImage\n  t1 labels that will be propagated to the NM</p>\n\n<p>brain_stem_dilation : integer default 8\n  dilates the brain stem mask to better match coverage of NM</p>\n\n<p>bias_correct : boolean</p>\n\n<p>denoise : None or integer</p>\n\n<p>srmodel : None -- this is a work in progress feature, probably not optimal</p>\n\n<p>target_range : 2-element tuple\n      a tuple or array defining the (min, max) of the input image\n      (e.g., [-127.5, 127.5] or [0,1]).  Output images will be scaled back to original\n      intensity. This range should match the mapping used in the training\n      of the network.</p>\n\n<p>poly_order : if not None, will fit a global regression model to map\n    intensity back to original histogram space; if 'hist' will match\n    by histogram matching - ants.histogram_match_image</p>\n\n<p>normalize_nm : boolean - WIP not validated</p>\n\n<p>verbose : boolean</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>Averaged and registered neuromelanin image and neuromelanin labels and wide csv</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">list_nm_images</span>,</span><span class=\"param\">\t<span class=\"n\">t1</span>,</span><span class=\"param\">\t<span class=\"n\">t1_head</span>,</span><span class=\"param\">\t<span class=\"n\">t1lab</span>,</span><span class=\"param\">\t<span class=\"n\">brain_stem_dilation</span><span class=\"o\">=</span><span class=\"mi\">8</span>,</span><span class=\"param\">\t<span class=\"n\">bias_correct</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">denoise</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">srmodel</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">target_range</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">poly_order</span><span class=\"o\">=</span><span class=\"s1\">&#39;hist&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">normalize_nm</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.resting_state_fmri_networks", "modulename": "antspymm.mm", "qualname": "resting_state_fmri_networks", "kind": "function", "doc": "<p>Compute resting state network correlation maps based on the J Power labels.\nThis will output a map for each of the major network systems.  This function \nwill by optionally upsample data to 2mm during the registration process if data \nis below that resolution.</p>\n\n<p>registration - despike - anatomy - smooth - nuisance - bandpass - regress.nuisance - censor - falff - correlations</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>fmri : BOLD fmri antsImage</p>\n\n<p>fmri_template : reference space for BOLD</p>\n\n<p>t1 : ANTsImage\n  input 3-D T1 brain image (brain extracted)</p>\n\n<p>t1segmentation : ANTsImage\n  t1 segmentation - a six tissue segmentation image in T1 space</p>\n\n<p>f : band pass limits for frequency filtering; we use high-pass here as per Shirer 2015</p>\n\n<p>spa : gaussian smoothing for spatial component (physical coordinates)</p>\n\n<p>spt : gaussian smoothing for temporal component</p>\n\n<p>nc  : number of components for compcor filtering; if less than 1 we estimate on the fly based on explained variance; 10 wrt Shirer 2015 5 from csf and 5 from wm</p>\n\n<p>ica_components : integer if greater than 0 then include ica components</p>\n\n<p>impute : boolean if True, then use imputation in f/ALFF, PerAF calculation</p>\n\n<p>censor : boolean if True, then use censoring (censoring)</p>\n\n<p>despike : if this is greater than zero will run voxel-wise despiking in the 3dDespike (afni) sense; after motion-correction</p>\n\n<p>motion_as_nuisance: boolean will add motion and first derivative of motion as nuisance</p>\n\n<p>powers : boolean if True use Powers nodes otherwise 2023 Yeo 500 homotopic nodes (10.1016/j.neuroimage.2023.120010)</p>\n\n<p>upsample : float optionally isotropically upsample data to upsample (the parameter value) in mm during the registration process if data is below that resolution; if the input spacing is less than that provided by the user, the data will simply be resampled to isotropic resolution</p>\n\n<p>clean_tmp : will automatically try to clean the tmp directory - not recommended but can be used in distributed computing systems to help prevent failures due to accumulation of tmp files when doing large-scale processing.  if this is set, the float value clean_tmp will be interpreted as the age in hours of files to be cleaned.</p>\n\n<p>verbose : boolean</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>a dictionary containing the derived network maps</p>\n\n<h2 id=\"references\">References</h2>\n\n<p>10.1162/netn_a_00071 \"Methods that included global signal regression were the most consistently effective de-noising strategies.\"</p>\n\n<p>10.1016/j.neuroimage.2019.116157 \"frontal and default model networks are most reliable whereas subcortical neteworks are least reliable\"  \"the most comprehensive studies of pipeline effects on edge-level reliability have been done by shirer (2015) and Parkes (2018)\" \"slice timing correction has minimal impact\" \"use of low-pass or narrow filter (discarding  high frequency information) reduced both reliability and signal-noise separation\"</p>\n\n<p>10.1016/j.neuroimage.2017.12.073: Our results indicate that (1) simple linear regression of regional fMRI time series against head motion parameters and WM/CSF signals (with or without expansion terms) is not sufficient to remove head motion artefacts; (2) aCompCor pipelines may only be viable in low-motion data; (3) volume censoring performs well at minimising motion-related artefact but a major benefit of this approach derives from the exclusion of high-motion individuals; (4) while not as effective as volume censoring, ICA-AROMA performed well across our benchmarks for relatively low cost in terms of data loss; (5) the addition of global signal regression improved the performance of nearly all pipelines on most benchmarks, but exacerbated the distance-dependence of correlations between motion and functional connec- tivity; and (6) group comparisons in functional connectivity between healthy controls and schizophrenia patients are highly dependent on preprocessing strategy. We offer some recommendations for best practice and outline simple analyses to facilitate transparent reporting of the degree to which a given set of findings may be affected by motion-related artefact.</p>\n\n<p>10.1016/j.dcn.2022.101087 : We found that: 1) the most efficacious pipeline for both noise removal and information recovery included censoring, GSR, bandpass filtering, and head motion parameter (HMP) regression, 2) ICA-AROMA performed similarly to HMP regression and did not obviate the need for censoring, 3) GSR had a minimal impact on connectome fingerprinting but improved ISC, and 4) the strictest censoring approaches reduced motion correlated edges but negatively impacted identifiability.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">fmri</span>,</span><span class=\"param\">\t<span class=\"n\">fmri_template</span>,</span><span class=\"param\">\t<span class=\"n\">t1</span>,</span><span class=\"param\">\t<span class=\"n\">t1segmentation</span>,</span><span class=\"param\">\t<span class=\"n\">f</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mf\">0.03</span><span class=\"p\">,</span> <span class=\"mf\">0.08</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">FD_threshold</span><span class=\"o\">=</span><span class=\"mf\">5.0</span>,</span><span class=\"param\">\t<span class=\"n\">spa</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">spt</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nc</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">outlier_threshold</span><span class=\"o\">=</span><span class=\"mf\">0.25</span>,</span><span class=\"param\">\t<span class=\"n\">ica_components</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">impute</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">censor</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">despike</span><span class=\"o\">=</span><span class=\"mf\">2.5</span>,</span><span class=\"param\">\t<span class=\"n\">motion_as_nuisance</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">powers</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">upsample</span><span class=\"o\">=</span><span class=\"mf\">3.0</span>,</span><span class=\"param\">\t<span class=\"n\">clean_tmp</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">paramset</span><span class=\"o\">=</span><span class=\"s1\">&#39;unset&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.write_bvals_bvecs", "modulename": "antspymm.mm", "qualname": "write_bvals_bvecs", "kind": "function", "doc": "<p>Write FSL FDT bvals and bvecs files</p>\n\n<p>adapted from dipy.external code</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>bvals : (N,) sequence\n   Vector with diffusion gradient strength (one per diffusion\n   acquisition, N=no of acquisitions)\nbvecs : (N, 3) array-like\n   diffusion gradient directions\nprefix : string\n   path to write FDT bvals, bvecs text files\n   None results in current working directory.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bvals</span>, </span><span class=\"param\"><span class=\"n\">bvecs</span>, </span><span class=\"param\"><span class=\"n\">prefix</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.crop_mcimage", "modulename": "antspymm.mm", "qualname": "crop_mcimage", "kind": "function", "doc": "<p>crop a time series (4D) image by a 3D mask</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x : raw image</p>\n\n<p>mask  : mask for cropping</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">mask</span>, </span><span class=\"param\"><span class=\"n\">padder</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.mm", "modulename": "antspymm.mm", "qualname": "mm", "kind": "function", "doc": "<p>Multiple modality processing and normalization</p>\n\n<p>aggregates modality-specific processing under one roof.  see individual\nmodality specific functions for details.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>t1_image : raw t1 image</p>\n\n<p>hier  : output of antspyt1w.hierarchical ( see read hierarchical )</p>\n\n<p>rsf_image : list of resting state fmri</p>\n\n<p>flair_image : flair</p>\n\n<p>nm_image_list : list of neuromelanin images</p>\n\n<p>dw_image : list of diffusion weighted images</p>\n\n<p>bvals : list of bvals file names</p>\n\n<p>bvecs : list of bvecs file names</p>\n\n<p>perfusion_image : single perfusion image</p>\n\n<p>srmodel : optional srmodel</p>\n\n<p>do_tractography : boolean</p>\n\n<p>do_kk : boolean to control whether we compute kelly kapowski thickness image (slow)</p>\n\n<p>do_normalization : template transformation if available</p>\n\n<p>group_template : optional reference template corresponding to the group_transform</p>\n\n<p>group_transform : optional transforms corresponding to the group_template</p>\n\n<p>target_range : 2-element tuple\n    a tuple or array defining the (min, max) of the input image\n    (e.g., [-127.5, 127.5] or [0,1]).  Output images will be scaled back to original\n    intensity. This range should match the mapping used in the training\n    of the network.</p>\n\n<p>dti_motion_correct : None Rigid or SyN</p>\n\n<p>dti_denoise : boolean</p>\n\n<p>perfusion_trim : optional integer number of time volumes to exclude from the front of the perfusion time series</p>\n\n<p>perfusion_m0_image : optional antsImage m0 associated with the perfusion time series</p>\n\n<p>perfusion_m0 : optional list containing indices of the m0 in the perfusion time series</p>\n\n<p>rsf_upsampling : optional upsampling parameter value in mm; if set to zero, no upsampling is done</p>\n\n<p>pet_3d_image : optional antsImage for a 3D pet; we make no assumptions about the contents of \n    this image.  we just process it and provide summary information.</p>\n\n<p>test_run : boolean </p>\n\n<p>verbose : boolean</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">t1_image</span>,</span><span class=\"param\">\t<span class=\"n\">hier</span>,</span><span class=\"param\">\t<span class=\"n\">rsf_image</span><span class=\"o\">=</span><span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">flair_image</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nm_image_list</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dw_image</span><span class=\"o\">=</span><span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">bvals</span><span class=\"o\">=</span><span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">bvecs</span><span class=\"o\">=</span><span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">perfusion_image</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">srmodel</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">do_tractography</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">do_kk</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">do_normalization</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">group_template</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">group_transform</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">target_range</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">dti_motion_correct</span><span class=\"o\">=</span><span class=\"s1\">&#39;antsRegistrationSyNQuickRepro[r]&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">dti_denoise</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">perfusion_trim</span><span class=\"o\">=</span><span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">perfusion_m0_image</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">perfusion_m0</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">rsf_upsampling</span><span class=\"o\">=</span><span class=\"mf\">3.0</span>,</span><span class=\"param\">\t<span class=\"n\">pet_3d_image</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">test_run</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.write_mm", "modulename": "antspymm.mm", "qualname": "write_mm", "kind": "function", "doc": "<p>write the tabular and normalization output of the mm function</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>output_prefix : prefix for file outputs - modality specific postfix will be added</p>\n\n<p>mm  : output of mm function for modality-space processing should be a dictionary with \n    dictionary entries for each modality.</p>\n\n<p>mm_norm : output of mm function for normalized processing</p>\n\n<p>t1wide : wide output data frame from t1 hierarchical</p>\n\n<p>separator : string or character separator for filenames</p>\n\n<p>verbose : boolean</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>both csv and image files written to disk.  the primary outputs will be\noutput_prefix + separator + 'mmwide.csv' and *norm.nii.gz images</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">output_prefix</span>,</span><span class=\"param\">\t<span class=\"n\">mm</span>,</span><span class=\"param\">\t<span class=\"n\">mm_norm</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">t1wide</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">separator</span><span class=\"o\">=</span><span class=\"s1\">&#39;_&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.mm_nrg", "modulename": "antspymm.mm", "qualname": "mm_nrg", "kind": "function", "doc": "<p>too dangerous to document ... use with care.</p>\n\n<p>processes multiple modality MRI specifically:</p>\n\n<ul>\n<li>T1w</li>\n<li>T2Flair</li>\n<li>DTI, DTI_LR, DTI_RL</li>\n<li>rsfMRI, rsfMRI_LR, rsfMRI_RL</li>\n<li>NM2DMT (neuromelanin)</li>\n</ul>\n\n<p>other modalities may be added later ...</p>\n\n<p>\"trust me, i know what i'm doing\" - sledgehammer</p>\n\n<p>convert to pynb via:\n    p2j mm.py -o</p>\n\n<p>convert the ipynb to html via:\n    jupyter nbconvert ANTsPyMM/tests/mm.ipynb --execute --to html</p>\n\n<p>this function assumes NRG format for the input data ....\nwe also assume that t1w hierarchical (if already done) was written\nvia its standardized write function.\nNRG = <a href=\"https://github.com/stnava/biomedicalDataOrganization\">https://github.com/stnava/biomedicalDataOrganization</a></p>\n\n<p>this function is verbose</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>studyid : must have columns 1. subjectID 2. date (in form 20220228) and 3. imageID\n    other relevant columns include nmid1-10, rsfid1, rsfid2, dtid1, dtid2, flairid;\n    these provide unique image IDs for these modalities: nm=neuromelanin, dti=diffusion tensor,\n    rsf=resting state fmri, flair=T2Flair.  none of these are required. only\n    t1 is required.  rsfid1/rsfid2 will be processed jointly. same for dtid1/dtid2 and nmid*.  see antspymm.generate_mm_dataframe</p>\n\n<p>sourcedir : a study specific folder containing individual subject folders</p>\n\n<p>sourcedatafoldername : root for source data e.g. \"images\"</p>\n\n<p>processDir : where output will go - parallel to sourcedatafoldername e.g.\n    \"processed\"</p>\n\n<p>mysep : define a character separator for filename components</p>\n\n<p>srmodel_T1 : False (default) - will add a great deal of time - or h5 filename, 2 chan</p>\n\n<p>srmodel_NM : False (default) - will add a great deal of time - or h5 filename, 1 chan</p>\n\n<p>srmodel_DTI : False (default) - will add a great deal of time - or h5 filename, 1 chan</p>\n\n<p>visualize : True - will plot some results to png</p>\n\n<p>nrg_modality_list : list of permissible modalities - always include [T1w] as base</p>\n\n<p>verbose : boolean</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>writes output to disk and potentially produces figures that may be\ncaptured in a ipynb / html file.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">studyid</span>,</span><span class=\"param\">\t<span class=\"n\">sourcedir</span><span class=\"o\">=</span><span class=\"s1\">&#39;/Users/stnava/data/PPMI/MV/example_s3_b/images/PPMI/&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">sourcedatafoldername</span><span class=\"o\">=</span><span class=\"s1\">&#39;images&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">processDir</span><span class=\"o\">=</span><span class=\"s1\">&#39;processed&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">mysep</span><span class=\"o\">=</span><span class=\"s1\">&#39;-&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">srmodel_T1</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">srmodel_NM</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">srmodel_DTI</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">visualize</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">nrg_modality_list</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">&#39;T1w&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;NM2DMT&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;DTI&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;T2Flair&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;rsfMRI&#39;</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.mm_csv", "modulename": "antspymm.mm", "qualname": "mm_csv", "kind": "function", "doc": "<p>too dangerous to document ... use with care.</p>\n\n<p>processes multiple modality MRI specifically:</p>\n\n<ul>\n<li>T1w</li>\n<li>T2Flair</li>\n<li>DTI, DTI_LR, DTI_RL</li>\n<li>rsfMRI, rsfMRI_LR, rsfMRI_RL</li>\n<li>NM2DMT (neuromelanin)</li>\n</ul>\n\n<p>other modalities may be added later ...</p>\n\n<p>\"trust me, i know what i'm doing\" - sledgehammer</p>\n\n<p>convert to pynb via:\n    p2j mm.py -o</p>\n\n<p>convert the ipynb to html via:\n    jupyter nbconvert ANTsPyMM/tests/mm.ipynb --execute --to html</p>\n\n<p>this function does not assume NRG format for the input data ....</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>studycsv : must have columns:\n    - subjectID\n    - date or session\n    - imageID\n    - modality\n    - sourcedir\n    - outputdir\n    - filename (path to the t1 image)\n    other relevant columns include nmid1-10, rsfid1, rsfid2, dtid1, dtid2, flairid;\n    these provide filenames for these modalities: nm=neuromelanin, dti=diffusion tensor,\n    rsf=resting state fmri, flair=T2Flair.  none of these are required. only\n    t1 is required. rsfid1/rsfid2 will be processed jointly. same for dtid1/dtid2 and nmid*.\n    see antspymm.generate_mm_dataframe</p>\n\n<p>sourcedir : a study specific folder containing individual subject folders</p>\n\n<p>outputdir : a study specific folder where individual output subject folders will go</p>\n\n<p>filename : the raw image filename (full path)</p>\n\n<p>srmodel_T1 : False (default) - will add a great deal of time - or h5 filename, 2 chan</p>\n\n<p>srmodel_NM : False (default) - will add a great deal of time - or h5 filename, 1 chan</p>\n\n<p>srmodel_DTI : False (default) - will add a great deal of time - or h5 filename, 1 chan</p>\n\n<p>dti_motion_correct : None, Rigid or SyN</p>\n\n<p>dti_denoise : boolean</p>\n\n<p>nrg_modality_list : optional; defaults to None; use to focus on a given modality</p>\n\n<p>normalization_template : optional; defaults to None; if present, all images will\n    be deformed into this space and the deformation will be stored with an extension\n    related to this variable.  this should be a brain extracted T1w image.</p>\n\n<p>normalization_template_output : optional string; defaults to None; naming for the \n    normalization_template outputs which will be in the T1w directory.</p>\n\n<p>normalization_template_transform_type : optional string transform type passed to ants.registration</p>\n\n<p>normalization_template_spacing : 3-tuple controlling the resolution at which registration is computed </p>\n\n<p>enantiomorphic: boolean (WIP)</p>\n\n<p>perfusion_trim : optional integer number of time volumes to exclude from the front of the perfusion time series</p>\n\n<p>perfusion_m0_image : optional m0 antsImage associated with the perfusion time series</p>\n\n<p>perfusion_m0 : optional list containing indices of the m0 in the perfusion time series</p>\n\n<p>rsf_upsampling : optional upsampling parameter value in mm; if set to zero, no upsampling is done</p>\n\n<p>pet3d : optional antsImage for PET (or other 3d scalar) data which we want to summarize</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>writes output to disk and produces figures</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">studycsv</span>,</span><span class=\"param\">\t<span class=\"n\">mysep</span><span class=\"o\">=</span><span class=\"s1\">&#39;-&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">srmodel_T1</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">srmodel_NM</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">srmodel_DTI</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">dti_motion_correct</span><span class=\"o\">=</span><span class=\"s1\">&#39;antsRegistrationSyNQuickRepro[r]&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">dti_denoise</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">nrg_modality_list</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">normalization_template</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">normalization_template_output</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">normalization_template_transform_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;antsRegistrationSyNRepro[s]&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">normalization_template_spacing</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">enantiomorphic</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">perfusion_trim</span><span class=\"o\">=</span><span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">perfusion_m0_image</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">perfusion_m0</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">rsf_upsampling</span><span class=\"o\">=</span><span class=\"mf\">3.0</span>,</span><span class=\"param\">\t<span class=\"n\">pet3d</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.collect_blind_qc_by_modality", "modulename": "antspymm.mm", "qualname": "collect_blind_qc_by_modality", "kind": "function", "doc": "<p>Collects blind QC data from multiple CSV files with the same modality.</p>\n\n<p>Args:</p>\n\n<p>modality_path (str): The path to the folder containing the CSV files.</p>\n\n<p>set_index_to_fn: boolean</p>\n\n<p>Returns:\nPandas DataFrame: A DataFrame containing all the blind QC data from the CSV files.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">modality_path</span>, </span><span class=\"param\"><span class=\"n\">set_index_to_fn</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.alffmap", "modulename": "antspymm.mm", "qualname": "alffmap", "kind": "function", "doc": "<p>Amplitude of Low Frequency Fluctuations (ALFF; Zang et al., 2007) and\nfractional Amplitude of Low Frequency Fluctuations (f/ALFF; Zou et al., 2008)\nare related measures that quantify the amplitude of low frequency\noscillations (LFOs).  This function outputs ALFF and fALFF for the input.\nsame function in ANTsR.</p>\n\n<p>x input vector for the time series of interest\nflo low frequency, typically 0.01\nfhi high frequency, typically 0.1\ntr the period associated with the vector x (inverse of frequency)\ndetrend detrend the input time series</p>\n\n<p>return vector is output showing ALFF and fALFF values</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">flo</span><span class=\"o\">=</span><span class=\"mf\">0.01</span>, </span><span class=\"param\"><span class=\"n\">fhi</span><span class=\"o\">=</span><span class=\"mf\">0.1</span>, </span><span class=\"param\"><span class=\"n\">tr</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">detrend</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.alff_image", "modulename": "antspymm.mm", "qualname": "alff_image", "kind": "function", "doc": "<p>Amplitude of Low Frequency Fluctuations (ALFF; Zang et al., 2007) and\nfractional Amplitude of Low Frequency Fluctuations (f/ALFF; Zou et al., 2008)\nare related measures that quantify the amplitude of low frequency\noscillations (LFOs).  This function outputs ALFF and fALFF for the input.</p>\n\n<p>x - input clean resting state fmri\nmask - mask over which to compute f/alff\nflo - low frequency, typically 0.01\nfhi - high frequency, typically 0.1\nnuisance - optional nuisance matrix</p>\n\n<p>return dictionary with ALFF and fALFF images</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">mask</span>, </span><span class=\"param\"><span class=\"n\">flo</span><span class=\"o\">=</span><span class=\"mf\">0.01</span>, </span><span class=\"param\"><span class=\"n\">fhi</span><span class=\"o\">=</span><span class=\"mf\">0.1</span>, </span><span class=\"param\"><span class=\"n\">nuisance</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.down2iso", "modulename": "antspymm.mm", "qualname": "down2iso", "kind": "function", "doc": "<p>will downsample an anisotropic image to an isotropic resolution</p>\n\n<p>x: input image</p>\n\n<p>interpolation: linear or nearestneighbor</p>\n\n<p>takemin : boolean map to min space; otherwise max</p>\n\n<p>return image downsampled to isotropic resolution</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">interpolation</span><span class=\"o\">=</span><span class=\"s1\">&#39;linear&#39;</span>, </span><span class=\"param\"><span class=\"n\">takemin</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.read_mm_csv", "modulename": "antspymm.mm", "qualname": "read_mm_csv", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">is_t1</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">colprefix</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">separator</span><span class=\"o\">=</span><span class=\"s1\">&#39;-&#39;</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.assemble_modality_specific_dataframes", "modulename": "antspymm.mm", "qualname": "assemble_modality_specific_dataframes", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">mm_wide_csvs</span>,</span><span class=\"param\">\t<span class=\"n\">hierdfin</span>,</span><span class=\"param\">\t<span class=\"n\">nrg_modality</span>,</span><span class=\"param\">\t<span class=\"n\">separator</span><span class=\"o\">=</span><span class=\"s1\">&#39;-&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">progress</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.bind_wide_mm_csvs", "modulename": "antspymm.mm", "qualname": "bind_wide_mm_csvs", "kind": "function", "doc": "<p>will convert a list of t1w hierarchical csv filenames to a merged dataframe</p>\n\n<p>returns a pair of data frames, the left side having all entries and the\n    right side having row averaged entries i.e. unique values for each visit</p>\n\n<p>set merge to False to return individual dataframes ( for debugging )</p>\n\n<p>return alldata, row_averaged_data</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mm_wide_csvs</span>, </span><span class=\"param\"><span class=\"n\">merge</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">separator</span><span class=\"o\">=</span><span class=\"s1\">&#39;-&#39;</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.merge_mm_dataframe", "modulename": "antspymm.mm", "qualname": "merge_mm_dataframe", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">hierdf</span>, </span><span class=\"param\"><span class=\"n\">mmdf</span>, </span><span class=\"param\"><span class=\"n\">mm_suffix</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.augment_image", "modulename": "antspymm.mm", "qualname": "augment_image", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">max_rot</span><span class=\"o\">=</span><span class=\"mi\">10</span>, </span><span class=\"param\"><span class=\"n\">nzsd</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.boot_wmh", "modulename": "antspymm.mm", "qualname": "boot_wmh", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">flair</span>,</span><span class=\"param\">\t<span class=\"n\">t1</span>,</span><span class=\"param\">\t<span class=\"n\">t1seg</span>,</span><span class=\"param\">\t<span class=\"n\">mmfromconvexhull</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">strict</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">probability_mask</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">prior_probability</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">n_simulations</span><span class=\"o\">=</span><span class=\"mi\">16</span>,</span><span class=\"param\">\t<span class=\"n\">random_seed</span><span class=\"o\">=</span><span class=\"mi\">42</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.threaded_bind_wide_mm_csvs", "modulename": "antspymm.mm", "qualname": "threaded_bind_wide_mm_csvs", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mm_wide_csvs</span>, </span><span class=\"param\"><span class=\"n\">n_workers</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.get_names_from_data_frame", "modulename": "antspymm.mm", "qualname": "get_names_from_data_frame", "kind": "function", "doc": "<p>data = {'Name':['Tom', 'nick', 'krish', 'jack'], 'Age':[20, 21, 19, 18]}\nantspymm.get_names_from_data_frame( ['e'], df )\nantspymm.get_names_from_data_frame( ['a','e'], df )\nantspymm.get_names_from_data_frame( ['e'], df, exclusions='N' )</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">demogIn</span>, </span><span class=\"param\"><span class=\"n\">exclusions</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.average_mm_df", "modulename": "antspymm.mm", "qualname": "average_mm_df", "kind": "function", "doc": "<p>jmrowavg, jmmcolavg, diagnostics = antspymm.average_mm_df( jmm_in, verbose=True )</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">jmm_in</span>, </span><span class=\"param\"><span class=\"n\">diagnostic_n</span><span class=\"o\">=</span><span class=\"mi\">25</span>, </span><span class=\"param\"><span class=\"n\">corr_thresh</span><span class=\"o\">=</span><span class=\"mf\">0.9</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.quick_viz_mm_nrg", "modulename": "antspymm.mm", "qualname": "quick_viz_mm_nrg", "kind": "function", "doc": "<p>This function creates visualizations of brain images for a specific subject in a project using ANTsPy.</p>\n\n<p>Args:</p>\n\n<p>sourcedir (str): Root folder for original data (if post=False) or processed data (post=True)</p>\n\n<p>projectid (str): Project name.</p>\n\n<p>sid (str): Subject unique id.</p>\n\n<p>dtid (str): Date.</p>\n\n<p>extract_brain (bool): If True, the function extracts the brain from the T1w image. Default is True.</p>\n\n<p>slice_factor (float): The slice to be visualized is determined by multiplying the image size by this factor. Default is 0.55.</p>\n\n<p>post ( bool ) : if True, will visualize example post-processing results.</p>\n\n<p>original_sourcedir (str): Root folder for original data (used if post=True)</p>\n\n<p>filename (str): Output path with extension (.png)</p>\n\n<p>verbose (bool): If True, information will be printed while running the function. Default is True.</p>\n\n<p>Returns:\nNone</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">sourcedir</span>,</span><span class=\"param\">\t<span class=\"n\">projectid</span>,</span><span class=\"param\">\t<span class=\"n\">sid</span>,</span><span class=\"param\">\t<span class=\"n\">dtid</span>,</span><span class=\"param\">\t<span class=\"n\">extract_brain</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">slice_factor</span><span class=\"o\">=</span><span class=\"mf\">0.55</span>,</span><span class=\"param\">\t<span class=\"n\">post</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">original_sourcedir</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.blind_image_assessment", "modulename": "antspymm.mm", "qualname": "blind_image_assessment", "kind": "function", "doc": "<p>quick blind image assessment and triplanar visualization of an image ... 4D input will be visualized and assessed in 3D.  produces a png and csv where csv contains:</p>\n\n<ul>\n<li><p>reflection error ( estimates asymmetry )</p></li>\n<li><p>brisq ( blind quality assessment )</p></li>\n<li><p>patch eigenvalue ratio ( blind quality assessment )</p></li>\n<li><p>PSNR and SSIM vs a smoothed reference (4D or 3D appropriate)</p></li>\n<li><p>mask volume ( estimates foreground object size )</p></li>\n<li><p>spacing</p></li>\n<li><p>dimension after cropping by mask</p></li>\n</ul>\n\n<p>image : character or image object usually a nifti image</p>\n\n<p>viz_filename : character for a png output image</p>\n\n<p>title : display a summary title on the png</p>\n\n<p>pull_rank : boolean</p>\n\n<p>resample : None, numeric max or min, resamples image to isotropy</p>\n\n<p>n_to_skip : 10 by default; samples time series every n_to_skip volume</p>\n\n<p>verbose : boolean</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">image</span>,</span><span class=\"param\">\t<span class=\"n\">viz_filename</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">title</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">pull_rank</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">resample</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">n_to_skip</span><span class=\"o\">=</span><span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.average_blind_qc_by_modality", "modulename": "antspymm.mm", "qualname": "average_blind_qc_by_modality", "kind": "function", "doc": "<p>Averages time series qc results to yield one entry per image. this also filters to \"known\" columns.</p>\n\n<p>Args:\nqc_full: pandas dataframe containing the full qc data.</p>\n\n<p>Returns:\npandas dataframe containing the processed qc data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">qc_full</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.best_mmm", "modulename": "antspymm.mm", "qualname": "best_mmm", "kind": "function", "doc": "<p>Selects the best repeats per modality.</p>\n\n<p>Args:\nwmod (str): the modality of the image ( 'T1w', 'T2Flair', 'NM2DMT' 'rsfMRI', 'DTI')</p>\n\n<p>mysep (str, optional): the separator used in the image file names. Defaults to '-'.</p>\n\n<p>outlier_name : column name for outlier score</p>\n\n<p>verbose (bool, optional): default True</p>\n\n<p>Returns:</p>\n\n<p>list: a list containing two metadata dataframes - raw and filt. raw contains all the metadata for the selected modality and filt contains the metadata filtered for highest quality repeats.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mmdf</span>, </span><span class=\"param\"><span class=\"n\">wmod</span>, </span><span class=\"param\"><span class=\"n\">mysep</span><span class=\"o\">=</span><span class=\"s1\">&#39;-&#39;</span>, </span><span class=\"param\"><span class=\"n\">outlier_column</span><span class=\"o\">=</span><span class=\"s1\">&#39;ol_loop&#39;</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.nrg_2_bids", "modulename": "antspymm.mm", "qualname": "nrg_2_bids", "kind": "function", "doc": "<p>Convert an NRG filename to BIDS path/filename.</p>\n\n<p>Parameters:\nnrg_filename (str): The NRG filename to convert.</p>\n\n<p>Returns:\nstr: The BIDS path/filename.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">nrg_filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.bids_2_nrg", "modulename": "antspymm.mm", "qualname": "bids_2_nrg", "kind": "function", "doc": "<p>Convert a BIDS filename to NRG path/filename.</p>\n\n<p>Parameters:\nbids_filename (str): The BIDS filename to convert\nproject_name (str) : Name of project (i.e. PPMI)\ndate (str) : Date of image acquisition</p>\n\n<p>Returns:\nstr: The NRG path/filename.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bids_filename</span>, </span><span class=\"param\"><span class=\"n\">project_name</span>, </span><span class=\"param\"><span class=\"n\">date</span>, </span><span class=\"param\"><span class=\"n\">nrg_modality</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.parse_nrg_filename", "modulename": "antspymm.mm", "qualname": "parse_nrg_filename", "kind": "function", "doc": "<p>split a NRG filename into its named parts</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">separator</span><span class=\"o\">=</span><span class=\"s1\">&#39;-&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.novelty_detection_svm", "modulename": "antspymm.mm", "qualname": "novelty_detection_svm", "kind": "function", "doc": "<p>This function performs novelty detection using One-Class SVM.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li><p>df_train (pandas dataframe): training data used to fit the model</p></li>\n<li><p>df_test (pandas dataframe): test data used to predict novelties</p></li>\n<li><p>nu (float): parameter controlling the fraction of training errors and the fraction of support vectors (default: 0.05)</p></li>\n<li><p>kernel (str): kernel type used in the SVM algorithm (default: 'rbf')</p></li>\n</ul>\n\n<p>Returns:</p>\n\n<p>predictions (pandas series): predicted labels for the test data (1 for novelties, 0 for inliers)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df_train</span>, </span><span class=\"param\"><span class=\"n\">df_test</span>, </span><span class=\"param\"><span class=\"n\">nu</span><span class=\"o\">=</span><span class=\"mf\">0.05</span>, </span><span class=\"param\"><span class=\"n\">kernel</span><span class=\"o\">=</span><span class=\"s1\">&#39;rbf&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.novelty_detection_ee", "modulename": "antspymm.mm", "qualname": "novelty_detection_ee", "kind": "function", "doc": "<p>This function performs novelty detection using Elliptic Envelope.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li><p>df_train (pandas dataframe): training data used to fit the model</p></li>\n<li><p>df_test (pandas dataframe): test data used to predict novelties</p></li>\n<li><p>contamination (float): parameter controlling the proportion of outliers in the data (default: 0.05)</p></li>\n</ul>\n\n<p>Returns:</p>\n\n<p>predictions (pandas series): predicted labels for the test data (1 for novelties, 0 for inliers)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df_train</span>, </span><span class=\"param\"><span class=\"n\">df_test</span>, </span><span class=\"param\"><span class=\"n\">contamination</span><span class=\"o\">=</span><span class=\"mf\">0.05</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.novelty_detection_lof", "modulename": "antspymm.mm", "qualname": "novelty_detection_lof", "kind": "function", "doc": "<p>This function performs novelty detection using Local Outlier Factor (LOF).</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li><p>df_train (pandas dataframe): training data used to fit the model</p></li>\n<li><p>df_test (pandas dataframe): test data used to predict novelties</p></li>\n<li><p>n_neighbors (int): number of neighbors used to compute the LOF (default: 20)</p></li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>predictions (pandas series): predicted labels for the test data (1 for novelties, 0 for inliers)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df_train</span>, </span><span class=\"param\"><span class=\"n\">df_test</span>, </span><span class=\"param\"><span class=\"n\">n_neighbors</span><span class=\"o\">=</span><span class=\"mi\">20</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.novelty_detection_loop", "modulename": "antspymm.mm", "qualname": "novelty_detection_loop", "kind": "function", "doc": "<p>This function performs novelty detection using Local Outlier Factor (LOF).</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li><p>df_train (pandas dataframe): training data used to fit the model</p></li>\n<li><p>df_test (pandas dataframe): test data used to predict novelties</p></li>\n<li><p>n_neighbors (int): number of neighbors used to compute the LOOP (default: 20)</p></li>\n<li><p>distance_metric : default minkowski</p></li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>predictions (pandas series): predicted labels for the test data (1 for novelties, 0 for inliers)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df_train</span>, </span><span class=\"param\"><span class=\"n\">df_test</span>, </span><span class=\"param\"><span class=\"n\">n_neighbors</span><span class=\"o\">=</span><span class=\"mi\">20</span>, </span><span class=\"param\"><span class=\"n\">distance_metric</span><span class=\"o\">=</span><span class=\"s1\">&#39;minkowski&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.novelty_detection_quantile", "modulename": "antspymm.mm", "qualname": "novelty_detection_quantile", "kind": "function", "doc": "<p>This function performs novelty detection using quantiles for each column.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li><p>df_train (pandas dataframe): training data used to fit the model</p></li>\n<li><p>df_test (pandas dataframe): test data used to predict novelties</p></li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>quantiles for the test sample at each column where values range in [0,1]\nand higher values mean the column is closer to the edge of the distribution</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df_train</span>, </span><span class=\"param\"><span class=\"n\">df_test</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.generate_mm_dataframe", "modulename": "antspymm.mm", "qualname": "generate_mm_dataframe", "kind": "function", "doc": "<p>Generate a DataFrame for medical imaging data with extensive validation of input parameters.</p>\n\n<p>This function creates a DataFrame containing information about medical imaging files,\nensuring that filenames match expected patterns for their modalities and that all\nrequired images exist. It also validates the number of filenames provided for specific\nmodalities like rsfMRI, DTI, and NM.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>projectID (str): Project identifier.</li>\n<li>subjectID (str): Subject identifier.</li>\n<li>date (str): Date of the imaging study.</li>\n<li>imageUniqueID (str): Unique image identifier.</li>\n<li>modality (str): Modality of the imaging study.</li>\n<li>source_image_directory (str): Directory of the source images.</li>\n<li>output_image_directory (str): Directory for output images.</li>\n<li>t1_filename (str): Filename of the T1-weighted image.</li>\n<li>flair_filename (list): List of filenames for FLAIR images.</li>\n<li>rsf_filenames (list): List of filenames for rsfMRI images.</li>\n<li>dti_filenames (list): List of filenames for DTI images.</li>\n<li>nm_filenames (list): List of filenames for NM images.</li>\n<li>perf_filename (list): List of filenames for perfusion images.</li>\n<li>pet3d_filename (list): List of filenames for pet3d images.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>pandas.DataFrame: A DataFrame containing the validated imaging study information.</li>\n</ul>\n\n<p>Raises:</p>\n\n<ul>\n<li>ValueError: If any validation checks fail or if the number of columns does not match the data.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">projectID</span>,</span><span class=\"param\">\t<span class=\"n\">subjectID</span>,</span><span class=\"param\">\t<span class=\"n\">date</span>,</span><span class=\"param\">\t<span class=\"n\">imageUniqueID</span>,</span><span class=\"param\">\t<span class=\"n\">modality</span>,</span><span class=\"param\">\t<span class=\"n\">source_image_directory</span>,</span><span class=\"param\">\t<span class=\"n\">output_image_directory</span>,</span><span class=\"param\">\t<span class=\"n\">t1_filename</span>,</span><span class=\"param\">\t<span class=\"n\">flair_filename</span><span class=\"o\">=</span><span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">rsf_filenames</span><span class=\"o\">=</span><span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">dti_filenames</span><span class=\"o\">=</span><span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">nm_filenames</span><span class=\"o\">=</span><span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">perf_filename</span><span class=\"o\">=</span><span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">pet3d_filename</span><span class=\"o\">=</span><span class=\"p\">[]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.aggregate_antspymm_results", "modulename": "antspymm.mm", "qualname": "aggregate_antspymm_results", "kind": "function", "doc": "<p>Aggregate ANTsPyMM results from the specified CSV file and save the aggregated results to a new CSV file.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>input_csv (str): File path of the input CSV file containing ANTsPyMM QC results averaged and with outlier measurements.</li>\n<li>subject_col (str): Name of the column to store subject IDs.</li>\n<li>date_col (str): Name of the column to store date information.</li>\n<li>image_col (str): Name of the column to store image IDs.</li>\n<li>date_column (str): Name of the column representing the date information.</li>\n<li>base_path (str): Base path for search paths. Defaults to \"./Processed/ANTsExpArt/\".</li>\n<li>hiervariable (str) : the string variable denoting the Hierarchical output</li>\n<li>valid_modalities (str array) : identifies for each modality; if None will be replaced by get_valid_modalities(long=True)</li>\n<li>verbose : boolean</li>\n</ul>\n\n<p>Note:\nThis function is tested under limited circumstances. Use with caution.</p>\n\n<p>Example usage:\nagg_df = aggregate_antspymm_results(\"qcdfaol.csv\", subject_col='subjectID', date_col='date', image_col='imageID', date_column='ses-1', base_path=\"./Your/Custom/Path/\")</p>\n\n<p>Author:\nAvants and ChatGPT</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">input_csv</span>,</span><span class=\"param\">\t<span class=\"n\">subject_col</span><span class=\"o\">=</span><span class=\"s1\">&#39;subjectID&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">date_col</span><span class=\"o\">=</span><span class=\"s1\">&#39;date&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">image_col</span><span class=\"o\">=</span><span class=\"s1\">&#39;imageID&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">date_column</span><span class=\"o\">=</span><span class=\"s1\">&#39;ses-1&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">base_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;./Processed/ANTsExpArt/&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">hiervariable</span><span class=\"o\">=</span><span class=\"s1\">&#39;T1wHierarchical&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">valid_modalities</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.aggregate_antspymm_results_sdf", "modulename": "antspymm.mm", "qualname": "aggregate_antspymm_results_sdf", "kind": "function", "doc": "<p>Aggregate ANTsPyMM results from the specified study data frame and store the aggregated results in a new data frame.  This assumes data is organized on disk \nas follows:  rootdir/projectID/subjectID/date/outputid/imageid/ where \noutputid is modality-specific and created by ANTsPyMM processing.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>study_df (pandas df): pandas data frame, output of generate_mm_dataframe.</li>\n<li>project_col (str): Name of the column that stores the project ID</li>\n<li>subject_col (str): Name of the column to store subject IDs.</li>\n<li>date_col (str): Name of the column to store date information.</li>\n<li>image_col (str): Name of the column to store image IDs.</li>\n<li>base_path (str): Base path for searching for processing outputs of ANTsPyMM.</li>\n<li>hiervariable (str) : the string variable denoting the Hierarchical output</li>\n<li>splitsep (str):  the separator used to split the filename</li>\n<li>idsep (str): the separator used to partition subjectid date and imageid \nfor example, if idsep is - then we have subjectid-date-imageid</li>\n<li>wild_card_modality_id (bool): keep if False for safer execution</li>\n<li>second_split (bool): this is a hack that will split the imageID by . and keep the first part of the split; may be needed when the input filenames contain .</li>\n<li>verbose : boolean</li>\n</ul>\n\n<p>Note:\nThis function is tested under limited circumstances. Use with caution.\nOne particular gotcha is if the imageID is stored as a numeric value in the dataframe \nbut is meant to be a string.  E.g. '000' (string) would be interpreted as 0 in the \nfile name glob.  This would miss the extant (on disk) csv.</p>\n\n<p>Example usage:\nagg_df = aggregate_antspymm_results_sdf( studydf, subject_col='subjectID', date_col='date', image_col='imageID', base_path=\"./Your/Custom/Path/\")</p>\n\n<p>Author:\nAvants and ChatGPT</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">study_df</span>,</span><span class=\"param\">\t<span class=\"n\">project_col</span><span class=\"o\">=</span><span class=\"s1\">&#39;projectID&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">subject_col</span><span class=\"o\">=</span><span class=\"s1\">&#39;subjectID&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">date_col</span><span class=\"o\">=</span><span class=\"s1\">&#39;date&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">image_col</span><span class=\"o\">=</span><span class=\"s1\">&#39;imageID&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">base_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;./&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">hiervariable</span><span class=\"o\">=</span><span class=\"s1\">&#39;T1wHierarchical&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">splitsep</span><span class=\"o\">=</span><span class=\"s1\">&#39;-&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">idsep</span><span class=\"o\">=</span><span class=\"s1\">&#39;-&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">wild_card_modality_id</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">second_split</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.study_dataframe_from_matched_dataframe", "modulename": "antspymm.mm", "qualname": "study_dataframe_from_matched_dataframe", "kind": "function", "doc": "<p>converts the output of antspymm.match_modalities dataframe (one row) to that needed for a study-driving dataframe for input to mm_csv</p>\n\n<p>matched_dataframe : output of antspymm.match_modalities</p>\n\n<p>rootdir : location for the input data root folder (in e.g. NRG format)</p>\n\n<p>outputdir : location for the output data</p>\n\n<p>verbose : boolean</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">matched_dataframe</span>, </span><span class=\"param\"><span class=\"n\">rootdir</span>, </span><span class=\"param\"><span class=\"n\">outputdir</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.merge_wides_to_study_dataframe", "modulename": "antspymm.mm", "qualname": "merge_wides_to_study_dataframe", "kind": "function", "doc": "<p>extend a study data frame with wide outputs</p>\n\n<p>sdf : the input study dataframe from antspymm QC output</p>\n\n<p>processing_dir:  the directory location of the processed data </p>\n\n<p>separator : string usually '-' or '_'</p>\n\n<p>sid_is_int : boolean set to True to cast unique subject ids to int; can be useful if they are inadvertently stored as float by pandas</p>\n\n<p>date_is_int : boolean set to True to cast date to int; can be useful if they are inadvertently stored as float by pandas</p>\n\n<p>id_is_int : boolean set to True to cast unique image ids to int; can be useful if they are inadvertently stored as float by pandas</p>\n\n<p>report_missing : boolean combined with verbose will report missing modalities</p>\n\n<p>progress : integer reports percent progress modulo progress value </p>\n\n<p>verbose : boolean</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">sdf</span>,</span><span class=\"param\">\t<span class=\"n\">processing_dir</span>,</span><span class=\"param\">\t<span class=\"n\">separator</span><span class=\"o\">=</span><span class=\"s1\">&#39;-&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">sid_is_int</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">id_is_int</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">date_is_int</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">report_missing</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">progress</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.filter_image_files", "modulename": "antspymm.mm", "qualname": "filter_image_files", "kind": "function", "doc": "<p>Filters a list of image file paths based on specified criteria and returns \nthe path of the image that best matches that criteria (smallest, largest, or brightest).</p>\n\n<p>Args:\nimage_paths (list): A list of file paths to the images.\ncriteria (str): Criteria for selecting the image ('smallest', 'largest', 'brightest').</p>\n\n<p>Returns:\nstr: The file path of the selected image, or None if no valid images are found.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">image_paths</span>, </span><span class=\"param\"><span class=\"n\">criteria</span><span class=\"o\">=</span><span class=\"s1\">&#39;largest&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.docsamson", "modulename": "antspymm.mm", "qualname": "docsamson", "kind": "function", "doc": "<p>Processes image file names based on the specified imaging modality and other parameters.</p>\n\n<p>The function selects file names from the provided dictionary <code>studycsv</code> based on the imaging modality.\nIt supports various modalities like T1w, T2Flair, perf, NM2DMT, rsfMRI, DTI, and configures the filenames accordingly.\nThe function can optionally print verbose output during processing.</p>\n\n<p>Parameters:\nlocmod (str): The imaging modality. Options include 'T1w', 'T2Flair', 'perf', 'NM2DMT', 'rsfMRI', 'DTI'.\nstudycsv (dict): A dictionary with keys corresponding to imaging modalities and values as file names.\noutputdir (str): Base directory for output files.\nprojid (str): Project identifier.\nsid (str): Subject identifier.\ndtid (str): Data acquisition time identifier.\nmysep (str): Separator used in file naming.\nt1iid (str, optional): Identifier related to T1-weighted images, used in naming output files when locmod is not 'T1w'.\nverbose (bool, optional): If True, prints detailed information during execution.</p>\n\n<p>Returns:\ndict: A dictionary with keys 'modality', 'outprefix', and 'images'.\n    - 'modality' (str): The imaging modality used.\n    - 'outprefix' (str): The prefix for output file paths.\n    - 'images' (list): A list of processed image file names.</p>\n\n<p>Notes:</p>\n\n<ul>\n<li>The function is designed to work within a specific workflow and might require adaptation for general use.</li>\n</ul>\n\n<p>Examples:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">docsamson</span><span class=\"p\">(</span><span class=\"s1\">&#39;T1w&#39;</span><span class=\"p\">,</span> <span class=\"n\">studycsv</span><span class=\"p\">,</span> <span class=\"n\">outputdir</span><span class=\"p\">,</span> <span class=\"n\">projid</span><span class=\"p\">,</span> <span class=\"n\">sid</span><span class=\"p\">,</span> <span class=\"n\">dtid</span><span class=\"p\">,</span> <span class=\"n\">mysep</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s1\">&#39;modality&#39;</span><span class=\"p\">])</span>\n<span class=\"go\">&#39;T1w&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s1\">&#39;outprefix&#39;</span><span class=\"p\">])</span>\n<span class=\"go\">&#39;/path/to/output/directory/T1w/some_identifier&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s1\">&#39;images&#39;</span><span class=\"p\">])</span>\n<span class=\"go\">[&#39;image1.nii&#39;, &#39;image2.nii&#39;]</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">locmod</span>,</span><span class=\"param\">\t<span class=\"n\">studycsv</span>,</span><span class=\"param\">\t<span class=\"n\">outputdir</span>,</span><span class=\"param\">\t<span class=\"n\">projid</span>,</span><span class=\"param\">\t<span class=\"n\">sid</span>,</span><span class=\"param\">\t<span class=\"n\">dtid</span>,</span><span class=\"param\">\t<span class=\"n\">mysep</span>,</span><span class=\"param\">\t<span class=\"n\">t1iid</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.enantiomorphic_filling_without_mask", "modulename": "antspymm.mm", "qualname": "enantiomorphic_filling_without_mask", "kind": "function", "doc": "<p>Perform an enantiomorphic lesion filling on an image without a lesion mask.</p>\n\n<p>Args:\nimage (antsImage): The ants image to flip and fill\naxis ( int ): the axis along which to reflect the image\nintensity ( str ) : low or high</p>\n\n<p>Returns:\nants.ANTsImage: The image after enantiomorphic filling.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">image</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">intensity</span><span class=\"o\">=</span><span class=\"s1\">&#39;low&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.wmh", "modulename": "antspymm.mm", "qualname": "wmh", "kind": "function", "doc": "<p>Outputs the WMH probability mask and a summary single measurement</p>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>flair : ANTsImage\n    input 3-D FLAIR brain image (not skull-stripped).</p>\n\n<p>t1 : ANTsImage\n    input 3-D T1 brain image (not skull-stripped).</p>\n\n<p>t1seg : ANTsImage\n    T1 segmentation image</p>\n\n<p>mmfromconvexhull : float\n    restrict WMH to regions that are WM or mmfromconvexhull mm away from the\n    convex hull of the cerebrum.   we choose a default value based on\n    Figure 4 from:\n    <a href=\"https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6240579/pdf/fnagi-10-00339.pdf\">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6240579/pdf/fnagi-10-00339.pdf</a></p>\n\n<p>strict: boolean - if True, only use convex hull distance</p>\n\n<p>probability_mask : None - use to compute wmh just once - then this function\n    just does refinement and summary</p>\n\n<p>prior_probability : optional prior probability image in space of the input t1</p>\n\n<p>model : either sysu or hyper</p>\n\n<p>verbose : boolean</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>WMH probability map and a summary single measurement which is the sum of the WMH map</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">flair</span>,</span><span class=\"param\">\t<span class=\"n\">t1</span>,</span><span class=\"param\">\t<span class=\"n\">t1seg</span>,</span><span class=\"param\">\t<span class=\"n\">mmfromconvexhull</span><span class=\"o\">=</span><span class=\"mf\">3.0</span>,</span><span class=\"param\">\t<span class=\"n\">strict</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">probability_mask</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">prior_probability</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"o\">=</span><span class=\"s1\">&#39;sysu&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.remove_elements_from_numpy_array", "modulename": "antspymm.mm", "qualname": "remove_elements_from_numpy_array", "kind": "function", "doc": "<p>Remove specified elements or rows from a numpy array.</p>\n\n<p>Parameters:\noriginal_array (numpy.ndarray): A numpy array from which elements or rows are to be removed.\nindices_to_remove (list or numpy.ndarray): Indices of elements or rows to be removed.</p>\n\n<p>Returns:\nnumpy.ndarray: A new numpy array with the specified elements or rows removed. If the input array is None,\n               the function returns None.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">original_array</span>, </span><span class=\"param\"><span class=\"n\">indices_to_remove</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.score_fmri_censoring", "modulename": "antspymm.mm", "qualname": "score_fmri_censoring", "kind": "function", "doc": "<p>Process CBF time series to remove high-leverage points.\nDerived from the SCORE algorithm by Sudipto Dolui et. al.</p>\n\n<p>Parameters:\ncbfts (ANTsImage): 4D ANTsImage of CBF time series.\ncsf_seg (ANTsImage): CSF binary map.\ngm_seg (ANTsImage): Gray matter binary map.\nwm_seg (ANTsImage): WM binary map.</p>\n\n<p>Returns:\nANTsImage: Processed CBF time series.\nndarray: Index of removed volumes.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cbfts</span>, </span><span class=\"param\"><span class=\"n\">csf_seg</span>, </span><span class=\"param\"><span class=\"n\">gm_seg</span>, </span><span class=\"param\"><span class=\"n\">wm_seg</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.remove_volumes_from_timeseries", "modulename": "antspymm.mm", "qualname": "remove_volumes_from_timeseries", "kind": "function", "doc": "<p>Remove specified volumes from a time series.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>time_series</strong>:  ANTsImage representing the time series (4D image).</li>\n<li><strong>volumes_to_remove</strong>:  List of volume indices to remove.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>ANTsImage with specified volumes removed.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">time_series</span>, </span><span class=\"param\"><span class=\"n\">volumes_to_remove</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.loop_timeseries_censoring", "modulename": "antspymm.mm", "qualname": "loop_timeseries_censoring", "kind": "function", "doc": "<p>Censor high leverage volumes from a time series using Local Outlier Probabilities (LoOP).</p>\n\n<p>Parameters:\nx (ANTsImage): A 4D time series image.\nthreshold (float): Threshold for determining high leverage volumes based on LoOP scores.\nmask (antsImage): restricts to a ROI\nn_features_sample (int/float): feature sample size default 0.01; if less than one then this is interpreted as a percentage of the total features otherwise it sets the number of features to be used\nseed (int): random seed\nverbose (bool)</p>\n\n<p>Returns:\ntuple: A tuple containing the censored time series (ANTsImage) and the indices of the high leverage volumes.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">n_features_sample</span><span class=\"o\">=</span><span class=\"mf\">0.02</span>,</span><span class=\"param\">\t<span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"mi\">42</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.clean_tmp_directory", "modulename": "antspymm.mm", "qualname": "clean_tmp_directory", "kind": "function", "doc": "<p>Clean the /tmp directory by removing files and directories older than a certain number of hours.\nOptionally uses sudo and can filter files by extensions.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>age_hours</strong>:  Age in hours to consider files and directories for deletion.</li>\n<li><strong>use_sudo</strong>:  Whether to use sudo for removal commands.</li>\n<li><strong>extensions</strong>:  List of file extensions to delete. If None, all files are considered.</li>\n<li><strong>log_file_path</strong>:  Path to the log file. If None, a default path will be used based on the OS.</li>\n</ul>\n\n<h1 id=\"usage\">Usage</h1>\n\n<h1 id=\"example-clean_tmp_directoryage_hours1-use_sudotrue-extensionslog-tmp\">Example: clean_tmp_directory(age_hours=1, use_sudo=True, extensions=['.log', '.tmp'])</h1>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">age_hours</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">use_sudo</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">extensions</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">&#39;.nii&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;.nii.gz&#39;</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">log_file_path</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.validate_nrg_file_format", "modulename": "antspymm.mm", "qualname": "validate_nrg_file_format", "kind": "function", "doc": "<p>is your path nrg-etic?\nValidates if a given path conforms to the NRG file format, taking into account known extensions\nand the expected directory structure.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong>:  The file path to validate.</li>\n<li><strong>separator</strong>:  The separator used in the filename and directory structure.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A tuple (bool, str) indicating whether the path is valid and a message explaining the validation result.</p>\n</blockquote>\n\n<p>: example</p>\n\n<p>ntfn='/Users/ntustison/Data/Stone/LIMBIC/NRG/ANTsLIMBIC/sub08C105120Yr/ses-1/rsfMRI_RL/000/ANTsLIMBIC_sub08C105120Yr_ses-1_rsfMRI_RL_000.nii.gz'\nntfngood='/Users/ntustison/Data/Stone/LIMBIC/NRG/ANTsLIMBIC/sub08C105120Yr/ses_1/rsfMRI_RL/000/ANTsLIMBIC-sub08C105120Yr-ses_1-rsfMRI_RL-000.nii.gz'</p>\n\n<p>validate_nrg_detailed(ntfngood, '-')\nprint( validate_nrg_detailed(ntfn, '-') )\nprint( validate_nrg_detailed(ntfn, '_') )</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span>, </span><span class=\"param\"><span class=\"n\">separator</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.ants_to_nibabel_affine", "modulename": "antspymm.mm", "qualname": "ants_to_nibabel_affine", "kind": "function", "doc": "<p>Convert an ANTsPy image (in LPS space) to a Nibabel-compatible affine (in RAS space).\nHandles 2D, 3D, 4D input (only spatial dimensions are encoded in the affine).</p>\n\n<p>Returns:\n    4x4 np.ndarray affine matrix in RAS space.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ants_img</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.mm.dict_to_dataframe", "modulename": "antspymm.mm", "qualname": "dict_to_dataframe", "kind": "function", "doc": "<p>Convert a dictionary to a pandas DataFrame, excluding items that cannot be processed by pandas.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data_dict</strong>:  Dictionary to be converted.</li>\n<li><strong>convert_lists</strong>:  boolean</li>\n<li><strong>convert_arrays</strong>:  boolean</li>\n<li><strong>convert_images</strong>:  boolean</li>\n<li><strong>verbose</strong>:  boolean</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>DataFrame representation of the dictionary.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data_dict</span>,</span><span class=\"param\">\t<span class=\"n\">convert_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">convert_arrays</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">convert_images</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "antspymm.rsfmri", "modulename": "antspymm.rsfmri", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "antspymm.rsfmri.resting_state_fmri_networks", "modulename": "antspymm.rsfmri", "qualname": "resting_state_fmri_networks", "kind": "function", "doc": "<p>Compute resting state network correlation maps based on the J Power labels.\nThis includes fMRI preprocessing steps and subsequent network analysis.</p>\n\n<p>Arguments are detailed in the function signature.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>a dictionary containing the derived network maps</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">fmri</span>,</span><span class=\"param\">\t<span class=\"n\">fmri_template</span>,</span><span class=\"param\">\t<span class=\"n\">t1</span>,</span><span class=\"param\">\t<span class=\"n\">t1segmentation</span>,</span><span class=\"param\">\t<span class=\"n\">f</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mf\">0.03</span><span class=\"p\">,</span> <span class=\"mf\">0.08</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">FD_threshold</span><span class=\"o\">=</span><span class=\"mf\">5.0</span>,</span><span class=\"param\">\t<span class=\"n\">spa</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">spt</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nc</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">outlier_threshold</span><span class=\"o\">=</span><span class=\"mf\">0.25</span>,</span><span class=\"param\">\t<span class=\"n\">ica_components</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">impute</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">censor</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">despike</span><span class=\"o\">=</span><span class=\"mf\">2.5</span>,</span><span class=\"param\">\t<span class=\"n\">motion_as_nuisance</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">powers</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">upsample</span><span class=\"o\">=</span><span class=\"mf\">3.0</span>,</span><span class=\"param\">\t<span class=\"n\">clean_tmp</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">paramset</span><span class=\"o\">=</span><span class=\"s1\">&#39;unset&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();